
R version 3.6.1 (2019-07-05) -- "Action of the Toes"
Copyright (C) 2019 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> #######################################################################
> # Copyright (c) 2020 Pedro Milanez-Almeida, Ph.D., NIAID/NIH
> #
> # License
> # The software is distributed under the terms of the
> # Artistic License 2.0
> # http://www.r-project.org/Licenses/Artistic-2.0
> #
> # Disclaimer
> # This software and documentation come with no warranties of any kind.
> # This software is provided "as is" and any express or implied
> # warranties, including, but not limited to, the implied warranties of
> # merchantability and fitness for a particular purpose are disclaimed.
> # In no event shall the  copyright holder be liable for any direct,
> # indirect, incidental, special, exemplary, or consequential damages
> # (including but not limited to, procurement of substitute goods or
> # services; loss of use, data or profits; or business interruption)
> # however caused and on any theory of liability, whether in contract,
> # strict liability, or tort arising in any way out of the use of this
> # software.
> ######################################################################
> 
> ## This will load required packages and, if not found, install them without updating old Bioc pckgs
> tryCatch(suppressMessages(library("foreach")), 
+          error = function(e){
+            install.packages(pkgs =  "foreach", 
+                             repos = 'http://cran.us.r-project.org')
+            suppressMessages(library("foreach"))
+          })
> tryCatch(suppressMessages(library("dplyr")), 
+          error = function(e){
+            install.packages(pkgs =  "dplyr", 
+                             repos = 'http://cran.us.r-project.org')
+            suppressMessages(library("dplyr"))
+          })
> tryCatch(suppressMessages(library("XML")), 
+          error = function(e){
+            install.packages(pkgs =  "XML", 
+                             repos = 'http://cran.us.r-project.org')
+            suppressMessages(library("XML"))
+          })
> tryCatch(suppressMessages(library("FlowSOM")), 
+          error = function(e){
+            if (!requireNamespace("BiocManager",
+                                  quietly = TRUE))
+              install.packages("BiocManager", 
+                               repos = 'http://cran.us.r-project.org')
+            BiocManager::install("FlowSOM",
+                                 update = FALSE,
+                                 ask = FALSE)
+            suppressMessages(library("FlowSOM"))
+          })
> tryCatch(suppressMessages(library("flowWorkspace")), 
+          error = function(e){
+            if (!requireNamespace("BiocManager",
+                                  quietly = TRUE))
+              install.packages("BiocManager", 
+                               repos = 'http://cran.us.r-project.org')
+            BiocManager::install("flowWorkspace",
+                                 update = FALSE,
+                                 ask = FALSE)
+            suppressMessages(library("flowWorkspace"))
+          })
> tryCatch(suppressMessages(library("CytoML")), 
+          error = function(e){
+            if (!requireNamespace("BiocManager",
+                                  quietly = TRUE))
+              install.packages("BiocManager", 
+                               repos = 'http://cran.us.r-project.org')
+            BiocManager::install("CytoML",
+                                 update = FALSE,
+                                 ask = FALSE)
+            suppressMessages(library("CytoML"))
+          })
> tryCatch(suppressMessages(library("flowUtils")), 
+          error = function(e){
+            if (!requireNamespace("BiocManager",
+                                  quietly = TRUE))
+              install.packages("BiocManager", 
+                               repos = 'http://cran.us.r-project.org')
+            BiocManager::install("flowUtils",
+                                 update = FALSE,
+                                 ask = FALSE)
+            suppressMessages(library("flowUtils"))
+          })
> 
> sessionInfo()
R version 3.6.1 (2019-07-05)
Platform: x86_64-w64-mingw32/x64 (64-bit)
Running under: Windows 10 x64 (build 18362)

Matrix products: default

locale:
[1] LC_COLLATE=English_United States.1252 
[2] LC_CTYPE=English_United States.1252   
[3] LC_MONETARY=English_United States.1252
[4] LC_NUMERIC=C                          
[5] LC_TIME=English_United States.1252    

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
 [1] flowUtils_1.48.0          CytoML_1.10.0            
 [3] flowWorkspace_3.32.0      ncdfFlow_2.30.1          
 [5] BH_1.69.0-1               RcppArmadillo_0.9.800.1.0
 [7] flowCore_1.50.0           FlowSOM_1.16.0           
 [9] igraph_1.2.4.1            XML_3.98-1.20            
[11] dplyr_0.8.3               foreach_1.4.7            

loaded via a namespace (and not attached):
 [1] Biobase_2.44.0              splines_3.6.1              
 [3] jsonlite_1.6                ConsensusClusterPlus_1.48.0
 [5] R.utils_2.9.0               ellipse_0.4.1              
 [7] gtools_3.8.1                RcppParallel_4.4.4         
 [9] assertthat_0.2.1            stats4_3.6.1               
[11] latticeExtra_0.6-28         RBGL_1.60.0                
[13] yaml_2.2.0                  robustbase_0.93-5          
[15] pillar_1.4.2                lattice_0.20-38            
[17] glue_1.3.1                  RUnit_0.4.32               
[19] digest_0.6.20               RColorBrewer_1.1-2         
[21] colorspace_1.4-1            ggcyto_1.12.0              
[23] Matrix_1.2-17               R.oo_1.22.0                
[25] plyr_1.8.4                  pcaPP_1.9-73               
[27] pkgconfig_2.0.3             tsne_0.1-3                 
[29] fda_2.4.8                   zlibbioc_1.30.0            
[31] purrr_0.3.2                 corpcor_1.6.9              
[33] mvtnorm_1.0-11              scales_1.0.0               
[35] openCyto_1.22.2             flowStats_3.42.0           
[37] tibble_2.1.3                ggplot2_3.2.1              
[39] flowViz_1.48.0              BiocGenerics_0.30.0        
[41] hexbin_1.27.3               lazyeval_0.2.2             
[43] mnormt_1.5-5                mclust_5.4.5               
[45] magrittr_1.5                crayon_1.3.4               
[47] IDPmisc_1.1.19              ks_1.11.5                  
[49] R.methodsS3_1.7.1           MASS_7.3-51.4              
[51] graph_1.62.0                tools_3.6.1                
[53] data.table_1.12.2           flowClust_3.22.0           
[55] matrixStats_0.55.0          stringr_1.4.0              
[57] munsell_0.5.0               cluster_2.1.0              
[59] compiler_3.6.1              rlang_0.4.0                
[61] grid_3.6.1                  iterators_1.0.12           
[63] base64enc_0.1-3             gtable_0.3.0               
[65] codetools_0.2-16            rrcov_1.4-7                
[67] R6_2.4.0                    gridExtra_2.3              
[69] clue_0.3-57                 KernSmooth_2.23-15         
[71] Rgraphviz_2.28.0            stringi_1.4.3              
[73] parallel_3.6.1              Rcpp_1.0.2                 
[75] DEoptimR_1.0-8              tidyselect_0.2.5           
> 
> populationName <- "Single Cells"
> minPopSize <- 500
> 
> 
> ## Code to read gates from wsp file
> popOfInt <- populationName
> popOfInt
[1] "Single Cells"
> 
> #find and load wsp file
> wspNames <- dirname(path = "C:/Users/pedro/OneDrive/Desktop/DAFi/13-Jan-2020/DAFi/T4  Monogenic-disease-HC_036-003.SingleCells.ExtNode.csv") %>% 
+   dirname(path = .) %>%
+   paste0(.,
+          ".wsp")
> wspNames
[1] "C:/Users/pedro/OneDrive/Desktop/DAFi/13-Jan-2020.wsp"
> ws <- openWorkspace(wspNames)
> ##find raw .fcs files
> #find path of all fcs files in workspace
> sampleFCS_paths <- xpathApply(ws@doc, 
+                               file.path("/Workspace/SampleList/Sample","DataSet"), 
+                               function(x) 
+                                 xmlGetAttr(x,"uri") %>%
+                                 gsub(pattern = "%20", replacement = " ", x = .) %>% 
+                                 gsub(pattern = "file:", replacement = "", x = .)) %>%
+   unlist
> sampleFCS_paths
[1] "/C:/Users/pedro/OneDrive/Desktop/DAFi/FCS/T4  Monogenic-disease-HC_036-003.fcs"
> #find name of fcs file used here
> excess.sampleFCS <- basename("C:/Users/pedro/OneDrive/Desktop/DAFi/13-Jan-2020/DAFi/T4  Monogenic-disease-HC_036-003.SingleCells.ExtNode.csv") %>% 
+   strsplit(x = .,
+            split = ".",
+            fixed = TRUE) %>% 
+   .[[1]] %>%
+   tail(.,3) %>%
+   paste0(.,
+          collapse = ".") %>%
+   paste0(".",
+          .)
> excess.sampleFCS
[1] ".SingleCells.ExtNode.csv"
> sampleFCS <- basename("C:/Users/pedro/OneDrive/Desktop/DAFi/13-Jan-2020/DAFi/T4  Monogenic-disease-HC_036-003.SingleCells.ExtNode.csv") %>%
+   gsub(pattern = excess.sampleFCS, 
+        replacement = "",
+        x = ., 
+        fixed = TRUE) %>%
+   paste0(.,
+          ".fcs")
> sampleFCS
[1] "T4  Monogenic-disease-HC_036-003.fcs"
> #find path to fcs file used here
> sampleFCS_path <- sampleFCS_paths[basename(sampleFCS_paths) == sampleFCS]
> sampleFCS_path
[1] "/C:/Users/pedro/OneDrive/Desktop/DAFi/FCS/T4  Monogenic-disease-HC_036-003.fcs"
> 
> if(Sys.info()["sysname"] == "Windows"){
+   sampleFCS_path <- substring(sampleFCS_path, 2)
+ }
> 
> #parse wsp and fcs files into a GatingSet object
> 
> pathFCS <- tryCatch(
+   data.frame(sampleID = getSamples(ws)$sampleID[getSamples(ws)$name == sampleFCS],
+              file = sampleFCS_path), 
+   error = function(e) {
+     FIL <- read.FCS(sampleFCS_path)@description$`$FIL`
+     data.frame(sampleID = getSamples(ws)$sampleID[getSamples(ws)$name == FIL],
+                file = sampleFCS_path)
+   })
> 
> gs <- parseWorkspace(ws, 
+                      name = 1,
+                      path = pathFCS, 
+                      isNcdf = FALSE)
Parsing 1 samples
windows version of flowJo workspace recognized.
version X
Creating flowSet...
loading data: C:/Users/pedro/OneDrive/Desktop/DAFi/FCS/T4  Monogenic-disease-HC_036-003.fcs
Compensating
gating ...
done!
> 
> #TODO: check for special characters in gates names and stop calc
> 
> orig.parNames <- getData(gs[[1]]) %>%
+   parameters(.) %>% 
+   pData(.) %>%
+   .$name
> 
> parNames <- c("FSC-A","SSC-A","FJComp-R710-A","FJComp-R780-A","FJComp-V450-A","FJComp-V545-A","FJComp-V605-A","FJComp-V655-A","FJComp-V800-A","FJComp-G610-A","FJComp-B515-A","FJComp-B710-A","FJComp-R660-A","FJComp-G560-A","FJComp-G660-A","FJComp-G710-A","FJComp-G780-A")
> 
> ## In CSV files, the parameter names are often like FJComp-xxx while in parNames we may be getting Comp-dsfdsdxxx
> FJCompToComp <- function(char_vec) {
+   if (any(grepl("FJComp", char_vec))) {
+     ## If it looks like there is FJComp-xxx in parNames but no FJComp-xxx in the column names of the FCS file, then
+     ## rename FJComp-xxx to Comp-xxx in the parNames and we will be looking for those instead.
+     new_char_vec <- gsub("^\\FJComp-", "Comp-", char_vec)
+     return(new_char_vec)
+   } else {
+     return(char_vec)
+   }
+ }
> changeFJSpecialChar <- function(char_vec, cor_char_vec) {
+   new_char_vec <- unlist(lapply(char_vec, function(name) {
+     if (name %in% cor_char_vec | name == "EventNumberDP") {
+       name
+     } else {
+       # Let's try [] to <>
+       name2 <- gsub("[", "<", name, fixed=TRUE)
+       name2 <- gsub("]", ">", name2, fixed=TRUE)
+       if (name2 %in% cor_char_vec) {
+         name2 # Worked, return it
+       } else {
+         # Previous fix did not do it, _ => / on the original names
+         name2 <- gsub("_", "/", name, fixed=TRUE)
+         if (name2 %in% cor_char_vec) {
+           name2 # Worked, return it
+         } else {
+           # That did not work either, let's try both [] => on top of the previous fix (_ => /)
+           name3 <- gsub("[", "<", name2, fixed=TRUE)
+           name3 <- gsub("]", ">", name3, fixed=TRUE)
+           if (name3 %in% cor_char_vec) {
+             name3 # Worked, finally, return it
+           } else {
+             ## Maybe we read a wrong dataset?
+             cat(paste("The input FCS file does not contain the provided input parameter, missing", name, "\n"))
+             "MISSINGPARAMETER"
+           }
+         }
+       }
+     }
+   }))
+   return(new_char_vec)
+ }
> 
> parNames <- FJCompToComp(parNames)
> parNames <- changeFJSpecialChar(parNames, orig.parNames)
> 
> parIndices <- match(parNames, getData(gs, "root") %>% 
+                       .[[1]] %>%
+                       parameters(.) %>%
+                       .$name)
> 
> if (length(parNames) == 0 || length(parIndices) == 0)
+   stop("Something seems wrong, it's like the input FCS file does not contain the provided input parameters.", call.=FALSE)
> 
> eventsCount <- getData(gs, "root") %>% 
+   .[[1]] %>%
+   dim %>% 
+   .[1]
> 
> if (length(parNames) == 0)
+   stop("Some input parameters need to be selected!", call.=FALSE)
> 
> if (length(parNames) == 0 || "MISSINGPARAMETER" %in% parNames)
+   stop("The input file is missing some of the specified parameters.", call.=FALSE)
> if (eventsCount == 0)
+   stop("R failed to read the input file.", call.=FALSE)
> 
> popOfInt_full_path <- getNodes(gs)[basename(getNodes(gs)) %in%
+                                      popOfInt]
> 
> #get info about gating hierarchy for each pop of interest
> names_gates_SOM <- foreach(pop = seq_along(basename(popOfInt_full_path))) %do% {
+   strsplit(x = getNodes(gs)[grepl(pattern = paste0("/",
+                                                    basename(popOfInt_full_path)[pop],
+                                                    "/"),
+                                   x = getNodes(gs),
+                                   fixed = TRUE)],
+            split = paste0(getNodes(gs)[grepl(pattern = paste0("/",
+                                                               basename(popOfInt_full_path)[pop],
+                                                               "$"), 
+                                              x = getNodes(gs),
+                                              fixed = FALSE)][1],
+                           "/"), 
+            fixed = TRUE) %>%
+     lapply(tail, 1) %>%
+     unlist
+ }
> names(names_gates_SOM) <- basename(popOfInt_full_path)
> 
> #to add recursive analysis, run whole DAFi process for each
> #non-terminal gate, adding the results to GatingSet as boolean filter
> 
> #find all gates down the gating hierarchy starting from the selected pop
> names_gates_of_int <- foreach(pop = seq_along(basename(popOfInt_full_path)),
+                               .final = unlist) %do% {
+                                 getNodes(gs)[grepl(pattern = paste0("/",
+                                                                     basename(popOfInt_full_path)[pop],
+                                                                     "/"),
+                                                    x = getNodes(gs),
+                                                    fixed = TRUE)]
+                               }
> #find non-terminal gates down the gating hierarchy, which will all be used in clustering
> names_gates_non_term <- unlist(names_gates_of_int, use.names = FALSE)[lapply(unlist(names_gates_of_int, use.names = FALSE),
+                                                                              function(gate_of_int)
+                                                                                grepl(pattern = paste0("/",
+                                                                                                       basename(gate_of_int),
+                                                                                                       "/"),
+                                                                                      x = unlist(names_gates_of_int, use.names = FALSE),
+                                                                                      fixed = TRUE) %>%
+                                                                                any) %>%
+                                                                         unlist]
> #change names of non-terminal gates to reflect the fact they will be DAFi-refined
> names_gates_non_term_to_SOM <- names_gates_non_term
> names_gates_non_term_to_SOM <- gsub(pattern = popOfInt_full_path,
+                                     replacement = "",
+                                     x = names_gates_non_term_to_SOM) %>%
+   strsplit(.,
+            split = "/") %>%
+   lapply(.,
+          function(pop)
+            pop[-1] %>%
+            paste0("DAFi_",
+                   .) %>%
+            paste0(.,
+                   collapse = "/") %>%
+            paste0(popOfInt_full_path,
+                   "/",
+                   .)) %>%
+   unlist(.)
> #gates that will be used in clustering and whose children will be refined
> names_gates_to_SOM <- c(popOfInt_full_path,
+                         names_gates_non_term_to_SOM)
> #find their position in the hiearchy
> tree_pos_gate_to_SOM <- strsplit(x = names_gates_to_SOM, 
+                                  split = "/", 
+                                  fixed = TRUE) %>%
+   lapply(length) %>%
+   unlist
> #actual DAFi
> for(pop_to_SOM in names_gates_to_SOM[order(tree_pos_gate_to_SOM)]) { #order is very important to ensure hierarchy of gates
+   print(pop_to_SOM)
+   for(fSample in seq_along(gs)) {
+     if(dim(getData(gs[[fSample]],
+                    pop_to_SOM)[,parIndices])[1] > minPopSize) { # in case a subpop is smaller than min #events, SOM is not applied
+       ## Code to read the GatingSet data from each population that will be analyzed with DAFi
+        if (nchar("None") > 5) { ## Expected either "None" or a valid file path
+          load("None")
+          fSOM <- NewData(fSOM, getData(gs[[fSample]],
+                                         pop_to_SOM)[,parIndices]);
+        } else {
+       fSOM <- ReadInput(getData(gs[[fSample]],
+                                 pop_to_SOM)[,parIndices],
+                         compensate = FALSE,
+                         transform = FALSE, 
+                         scale = TRUE,
+                         silent = TRUE)
+        }
+       ## Code to generate SOM centroids
+       fSOM <- BuildSOM(fSOM,
+                        colsToUse = parNames,
+                        silent = TRUE,
+                        xdim = 10,
+                        ydim = 10)
+       ## Code to gate flowSOM results
+       #retrieve codes
+       if(TRUE) {
+         codes <- t(apply(fSOM$map$codes, 
+                          1,
+                          function(centroid)
+                            centroid * 
+                            fSOM$scaled.scale[parNames] + 
+                            fSOM$scaled.center[parNames]))
+       } else {
+         codes <- fSOM$map$codes
+       }
+       ls_fSOM <- list(codes)
+       names(ls_fSOM) <- rownames(pData(gs[[fSample]]))
+       #create FlowSet with FlowSOM centroids
+       fS_SOM <- lapply(ls_fSOM,
+                        function(sample)
+                          flowCore::flowFrame(sample)) %>%
+         flowSet()
+       parameters(fS_SOM[[1]]) <- parameters(getData(gs[[fSample]], 
+                                                     y = "root")[,parIndices])
+       #create GatingSet with FlowSOM centroids
+       suppressMessages(gs_SOM <- GatingSet(fS_SOM))
+       pData(gs_SOM) <- pData(gs[[fSample]])
+       #get gates and apply to cluster centroids
+       gates <- basename(getNodes(gs[[fSample]]))[
+         lapply(strsplit(x = dirname(getNodes(gs[[fSample]])),
+                         split = "/"),
+                function(nodes)
+                  tail(nodes, n = 1) == gsub(pattern = "DAFi_", 
+                                             replacement = "",
+                                             basename(pop_to_SOM))) %>%
+           unlist %>%
+           which]
+       for(gate in gates) {
+         suppressMessages(add(gs_SOM, 
+                              getGate(gs[[fSample]], 
+                                      gsub(pattern = "DAFi_",
+                                           replacement = "",
+                                           paste0(pop_to_SOM,
+                                                  "/", gate)))))
+       }
+       suppressMessages(recompute(gs_SOM))
+       ## Code to update assignment of cell identity according to DAFi results
+       SOM_labels <- vector(mode = "list",
+                            length = length(gates))
+       names(SOM_labels) <- gates
+       for(gate in gates){
+         SOM_labels[[gate]] <- rep(FALSE, 
+                                   10*10)
+       }
+       for(gate in gates) {
+         SOM_labels[[gate]][getIndices(gs_SOM[[1]], 
+                                       gate)] <- TRUE
+       }
+       cell_DAFi_label <- vector(mode = "list",
+                                 length = length(gates))
+       names(cell_DAFi_label) <- gates
+       for(gate in gates) {
+         cell_DAFi_label[[gate]] <- SOM_labels[[gate]][fSOM$map$mapping[,1]]
+       }
+       all_cells_DAFi_label <- vector(mode = "list",
+                                      length = length(gates))
+       names(all_cells_DAFi_label) <- gates
+       for(gate in gates) {
+         all_cells_DAFi_label[[gate]] <- rep(FALSE, 
+                                             length(getIndices(gs[[fSample]],
+                                                               y = pop_to_SOM)))
+         all_cells_DAFi_label[[gate]][
+           getIndices(gs[[fSample]],
+                      y = pop_to_SOM)] <- cell_DAFi_label[[gate]]
+         all_cells_DAFi_label[[gate]] <- list(all_cells_DAFi_label[[gate]])
+         names(all_cells_DAFi_label[[gate]]) <- sampleNames(gs[[fSample]])
+       }
+       for(gate in gates) {
+         add(gs[[fSample]],
+             all_cells_DAFi_label[[gate]], 
+             parent = pop_to_SOM, 
+             name = paste0("DAFi_", gate))
+       }
+       suppressMessages(recompute(gs[[fSample]]))
+     } else {
+       gates <- basename(getNodes(gs[[fSample]]))[
+         lapply(strsplit(x = dirname(getNodes(gs[[fSample]])),
+                         split = "/"),
+                function(nodes)
+                  tail(nodes, n = 1) == gsub(pattern = "DAFi_", 
+                                             replacement = "",
+                                             basename(pop_to_SOM))) %>%
+           unlist %>%
+           which]
+       for(gate in gates) {
+         add(gs[[fSample]], 
+             getGate(gs[[fSample]], 
+                     gsub(pattern = "DAFi_",
+                          replacement = "",
+                          paste0(pop_to_SOM,
+                                 "/", gate))),
+             parent = pop_to_SOM,
+             name = paste0("DAFi_",
+                           gate))
+       }
+       suppressMessages(recompute(gs[[fSample]]))
+     }
+   }
+ }
[1] "/FSC-A, Viability subset/FSC-A, SSC-A subset/Single Cells"
> 
> DAFi_nodes <- getNodes(gs)[grep(pattern = "DAFi_",
+                                 x = basename(getNodes(gs)),
+                                 fixed = TRUE)]
> DAFi_nodes <- DAFi_nodes[grep(pattern = popOfInt,
+                               x = DAFi_nodes,
+                               fixed = TRUE)]
> all_cell_DAFi_label <- foreach(DAFi_node = DAFi_nodes) %do% {
+   getIndices(gs[[1]], 
+              DAFi_node)
+ }
> names(all_cell_DAFi_label) <- DAFi_nodes
> EventNumberDP <- read.csv(file = "C:/Users/pedro/OneDrive/Desktop/DAFi/13-Jan-2020/DAFi/T4  Monogenic-disease-HC_036-003.SingleCells.ExtNode.csv",
+                           check.names=FALSE)$EventNumberDP
> FJ_event_DAFi_label <- foreach(DAFi_node = DAFi_nodes) %do% {
+   all_cell_DAFi_label[[DAFi_node]][EventNumberDP]
+ }
> names(FJ_event_DAFi_label) <- DAFi_nodes
> 
> ## Extract DAFi clustering to pass back to FlowJo (or SeqGeq)
> labels.ls <- foreach(DAFi_node = DAFi_nodes) %do% {
+   ## Please note "FJ_event_DAFi_label" here stemming from DAFi
+   ## FlowJo, let's do labels as 100, 200, 300, all with a tiny bit of noise (to make FlowJo cluster those better)
+   label <- as.matrix(FJ_event_DAFi_label[[DAFi_node]] %>% 
+                        as.integer(.))
+ }
> names(labels.ls) <- DAFi_nodes
> 
> labels <- matrix(unlist(labels.ls, 
+                         use.names = FALSE),
+                  ncol = length(labels.ls),
+                  byrow = FALSE)
> colnames(labels) <- foreach(DAFi_node = DAFi_nodes,
+                             .final = unlist) %do% {
+                               DAFi_node %>% 
+                                 strsplit(x = .,
+                                          split = paste0(popOfInt),
+                                          fixed = TRUE) %>% 
+                                 .[[1]] %>%
+                                 tail(.,1) %>%
+                                 paste0(popOfInt,
+                                        .) %>%
+                                 gsub(pattern = "/",
+                                      replacement = "_",
+                                      x = .,
+                                      fixed = TRUE)
+                             }
> colnames(labels) <- gsub(x = colnames(labels),
+                          pattern = ",",
+                          replacement = ".",
+                          fixed = TRUE)
> 
> #sanity check
> apply(labels,
+       2,
+       function(pop)
+         mean(pop > 0))
Single Cells_DAFi_CD3. CD45 subset 
                         0.7483207 
> #write results
> write.csv(labels, file="C:/Users/pedro/OneDrive/Desktop/DAFi/13-Jan-2020/DAFi/T4__Monogenic-disease-HC_036-003.SingleCells.csv.DAFi.csv", row.names=FALSE, quote=FALSE)
> write.csv(parNames, paste0("C:/Users/pedro/OneDrive/Desktop/DAFi/13-Jan-2020/DAFi/T4__Monogenic-disease-HC_036-003.SingleCells.csv.DAFi.csv", ".pars.csv"), row.names=FALSE)
> 
> all.labels.ls <- foreach(DAFi_node = DAFi_nodes) %do% {
+   all.label <- as.matrix(all_cell_DAFi_label[[DAFi_node]] %>% 
+                            as.integer(.))
+ }
> names(all.labels.ls) <- DAFi_nodes
> 
> all.labels <- matrix(unlist(all.labels.ls, 
+                             use.names = FALSE),
+                      ncol = length(all.labels.ls),
+                      byrow = FALSE)
> colnames(all.labels) <- foreach(DAFi_node = DAFi_nodes,
+                                 .final = unlist) %do% {
+                                   DAFi_node %>% 
+                                     strsplit(x = .,
+                                              split = paste0(popOfInt),
+                                              fixed = TRUE) %>% 
+                                     .[[1]] %>%
+                                     tail(.,1) %>%
+                                     paste0(popOfInt,
+                                            .) %>%
+                                     gsub(pattern = "/",
+                                          replacement = "_",
+                                          x = .,
+                                          fixed = TRUE)
+                                 }
> #2nd sanity check
> apply(all.labels,
+       2,
+       function(pop)
+         mean(pop > 0))
Single Cells_DAFi_CD3, CD45 subset 
                         0.2756949 
> 
> ls_ML <- list(all.labels)
> names(ls_ML) <- "ls_ML"
> #create FlowSet with DAFi results
> fS_ML <- lapply(ls_ML,
+                 function(sample)
+                   flowCore::flowFrame(sample)) %>%
+   flowSet()
> #create GatingSet with DAFi results
> gs_ML <- GatingSet(fS_ML)
.done!
> 
> for(pop in colnames(all.labels)) {
+   mat <- matrix(c(0.5, 1.5), 
+                 ncol = 1,
+                 dimnames = list(c("min", "max"),
+                                 pop))
+   rg <- rectangleGate(filterId = pop,
+                       .gate = mat)
+   add(gs_ML[["ls_ML"]], 
+       rg,
+       parent = "root",
+       name = pop)
+ }
> suppressMessages(recompute(gs_ML[["ls_ML"]]))
> 
> #3rd sanity check
> foreach(pop = colnames(all.labels)) %do% {
+   getIndices(gs_ML[["ls_ML"]], 
+              pop) %>%
+     mean(.)
+ } %>% unlist(.)
[1] 0.2756949
> 
> colnames(all.labels) <- gsub(x = colnames(all.labels),
+                              pattern = ",",
+                              replacement = ".",
+                              fixed = TRUE)
> 
> flowEnv <- new.env()
> 
> for(pop in colnames(all.labels)) {
+   mat <- matrix(c(0.5, 1.5), 
+                 ncol = 1,
+                 dimnames = list(c("min", "max"),
+                                 pop))
+   rg <- rectangleGate(filterId = pop,
+                       .gate = mat)
+   flowEnv[[as.character(pop)]] <- rg
+   }
> 
> outputFile <- paste0("C:/Users/pedro/OneDrive/Desktop/DAFi/13-Jan-2020/DAFi/T4  Monogenic-disease-HC_036-003.SingleCells.ExtNode.csv",
+                          ".gating-ml2.xml")
> write.gatingML(flowEnv, outputFile)
> 
> # R seems to be saving the .RData when exiting, so let's clean up to at least make that tiny (i.e., empty environment)
> rm(list=ls())
> 
> proc.time()
   user  system elapsed 
  11.18    0.68   12.07 
Error in gzfile(file, "wb") : cannot open the connection
Calls: sys.save.image -> save.image -> save -> gzfile
In addition: Warning message:
In gzfile(file, "wb") :
  cannot open compressed file '.RDataTmp', probable reason 'Permission denied'
Execution halted
Warning message:
In file.remove(outfile) :
  cannot remove file '.RDataTmp', reason 'No such file or directory'
