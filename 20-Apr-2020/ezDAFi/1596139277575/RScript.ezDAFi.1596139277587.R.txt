
R version 3.6.2 (2019-12-12) -- "Dark and Stormy Night"
Copyright (C) 2019 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Previously saved workspace restored]

> #######################################################################
> # Copyright (c) 2020 Pedro Milanez-Almeida, Ph.D., NIAID/NIH
> #
> # Parts of this code were modified from the source of the packages used here.
> # Credits for these parts go to the authors of the packages.
> # See list of all packages used below.
> #
> # License
> # The software is distributed under the terms of the
> # Artistic License 2.0
> # http://www.r-project.org/Licenses/Artistic-2.0
> #
> # Disclaimer
> # This software and documentation come with no warranties of any kind.
> # This software is provided "as is" and any express or implied
> # warranties, including, but not limited to, the implied warranties of
> # merchantability and fitness for a particular purpose are disclaimed.
> # In no event shall the  copyright holder be liable for any direct,
> # indirect, incidental, special, exemplary, or consequential damages
> # (including but not limited to, procurement of substitute goods or
> # services; loss of use, data or profits; or business interruption)
> # however caused and on any theory of liability, whether in contract,
> # strict liability, or tort arising in any way out of the use of this
> # software.
> ######################################################################
> 
> #test whether R version older than 3.6.2
> Rver.maj <- version$major
> Rver.min.1 <- strsplit(x = version$minor, 
+                        split = ".",
+                        fixed = TRUE,
+                        perl = FALSE, 
+                        useBytes = FALSE)[[1]][1]
> Rver.min.2 <- strsplit(x = version$minor, 
+                        split = ".",
+                        fixed = TRUE,
+                        perl = FALSE, 
+                        useBytes = FALSE)[[1]][2]
> 
> if(Rver.maj < 3){
+   stop(paste0("The plugin cannot run with R versions older than 3.6.2. ",
+               "Your version is: ",
+               paste0(version$major, ".", version$minor),
+               ". Please, update R and try again."))
+ } else if(Rver.maj == 3 & 
+           Rver.min.1 < 6){
+   stop(paste0("The plugin cannot run with R versions older than 3.6.2. ",
+               "Your version is: ",
+               paste0(version$major, ".", version$minor),
+               ". Please, update R and try again."))
+ } else if(Rver.maj == 3 & 
+           Rver.min.1 == 6 &
+           Rver.min.2 < 2) {
+   stop(paste0("The plugin cannot run with R versions older than 3.6.2. ",
+               "Your version is: ",
+               paste0(version$major, ".", version$minor),
+               ". Please, update R and try again."))
+ }
> 
> tryCatch(suppressMessages(library("BiocManager")),
+          error = function(e){
+            if (!requireNamespace("BiocManager",
+                                  quietly = TRUE))
+              install.packages("BiocManager",
+                               repos = 'http://cran.us.r-project.org')
+            suppressMessages(library("BiocManager"))
+          })
> 
> Bioc.ver.maj <- strsplit(x = as.character(BiocManager::version()), 
+                          split = ".",
+                          fixed = TRUE,
+                          perl = FALSE, 
+                          useBytes = FALSE)[[1]][1]
> Bioc.ver.min <- strsplit(x = as.character(BiocManager::version()), 
+                          split = ".",
+                          fixed = TRUE,
+                          perl = FALSE, 
+                          useBytes = FALSE)[[1]][2]
> 
> if(Bioc.ver.maj < 3){
+   stop(paste0("The plugin cannot run with Bioconductor releases older than 3.10. ",
+               "Your version is: ",
+               BiocManager::version(),
+               ". Please, update Bioconductor (visit https://www.bioconductor.org/install/) and try again."))
+ } else if(Bioc.ver.maj == 3 & 
+           Bioc.ver.min < 10){
+   stop("The plugin cannot run with Bioconductor releases older than 3.10. ",
+        "Your version is: ",
+        BiocManager::version(),
+        ". Please, update Bioconductor (visit https://www.bioconductor.org/install/) and try again.")
+ }
> 
> 
> ## This will load required packages and, if not found, install them without updating old Bioc pckgs
> tryCatch(suppressMessages(library("foreach")),
+          error = function(e){
+            install.packages(pkgs =  "foreach",
+                             repos = 'http://cran.us.r-project.org')
+            suppressMessages(library("foreach"))
+          })
> tryCatch(suppressMessages(library("pheatmap")),
+          error = function(e){
+            install.packages(pkgs =  "pheatmap",
+                             repos = 'http://cran.us.r-project.org')
+            suppressMessages(library("pheatmap"))
+          })
> tryCatch(suppressMessages(library("gridExtra")),
+          error = function(e){
+            install.packages(pkgs =  "gridExtra",
+                             repos = 'http://cran.us.r-project.org')
+            suppressMessages(library("gridExtra"))
+          })
> tryCatch(suppressMessages(library("Rcpp")),
+          error = function(e){
+            install.packages(pkgs =  "Rcpp",
+                             repos = 'http://cran.us.r-project.org')
+            suppressMessages(library("Rcpp"))
+          })
> tryCatch(suppressMessages(library("glue")),
+          error = function(e){
+            install.packages(pkgs =  "glue",
+                             repos = 'http://cran.us.r-project.org')
+            suppressMessages(library("glue"))
+          })
> tryCatch(suppressMessages(library("magrittr")),
+          error = function(e){
+            install.packages(pkgs =  "magrittr",
+                             repos = 'http://cran.us.r-project.org')
+            suppressMessages(library("magrittr"))
+          })
> tryCatch(suppressMessages(library("XML")),
+          error = function(e){
+            install.packages(pkgs =  "XML",
+                             repos = 'http://cran.us.r-project.org')
+            suppressMessages(library("XML"))
+          })
> #tryCatch(suppressMessages(library("pls")),
> #         error = function(e){
> #          install.packages(pkgs =  "pls",
> #                           repos = 'http://cran.us.r-project.org')
> #          suppressMessages(library("pls"))
> #        })
> tryCatch(suppressMessages(library("FlowSOM")),
+          error = function(e){
+            if (!requireNamespace("BiocManager",
+                                  quietly = TRUE))
+              install.packages("BiocManager",
+                               repos = 'http://cran.us.r-project.org')
+            BiocManager::install("FlowSOM",
+                                 update = FALSE,
+                                 ask = FALSE)
+            suppressMessages(library("FlowSOM"))
+          })
Warning message:
In .getGeneric(f, where, package) :
  strings not representable in native encoding will be translated to UTF-8
> tryCatch(suppressMessages(library("flowWorkspace")),
+          error = function(e){
+            if (!requireNamespace("BiocManager",
+                                  quietly = TRUE))
+              install.packages("BiocManager",
+                               repos = 'http://cran.us.r-project.org')
+            BiocManager::install("flowWorkspace",
+                                 update = FALSE,
+                                 ask = FALSE)
+            suppressMessages(library("flowWorkspace"))
+          })
> tryCatch(suppressMessages(library("CytoML")),
+          error = function(e){
+            if (!requireNamespace("BiocManager",
+                                  quietly = TRUE))
+              install.packages("BiocManager",
+                               repos = 'http://cran.us.r-project.org')
+            BiocManager::install("CytoML",
+                                 update = FALSE,
+                                 ask = FALSE)
+            suppressMessages(library("CytoML"))
+          })
Warning message:
package 'CytoML' was built under R version 3.6.3 
> tryCatch(suppressMessages(library("flowUtils")),
+          error = function(e){
+            if (!requireNamespace("BiocManager",
+                                  quietly = TRUE))
+              install.packages("BiocManager",
+                               repos = 'http://cran.us.r-project.org')
+            BiocManager::install("flowUtils",
+                                 update = FALSE,
+                                 ask = FALSE)
+            suppressMessages(library("flowUtils"))
+          })
> tryCatch(suppressMessages(library("flowCore")),
+          error = function(e){
+            if (!requireNamespace("BiocManager",
+                                  quietly = TRUE))
+              install.packages("BiocManager",
+                               repos = 'http://cran.us.r-project.org')
+            BiocManager::install("flowCore",
+                                 update = FALSE,
+                                 ask = FALSE)
+            suppressMessages(library("flowCore"))
+          })
> tryCatch(suppressMessages(library("ggcyto")),
+          error = function(e){
+            if (!requireNamespace("BiocManager",
+                                  quietly = TRUE))
+              install.packages("BiocManager",
+                               repos = 'http://cran.us.r-project.org')
+            BiocManager::install("ggcyto",
+                                 update = FALSE,
+                                 ask = FALSE)
+            suppressMessages(library("ggcyto"))
+          })
> #elbow_finder <- function(y_values) { #https://stackoverflow.com/a/42810075
> #  # Max values to create line
> # x_values <- seq_along(y_values)
> # max_x_x <- max(x_values)
> # max_x_y <- y_values[which.max(x_values)]
> # max_y_y <- max(y_values)
> # max_y_x <- x_values[which.max(y_values)]
> # max_df <- data.frame(x = c(max_y_x, max_x_x), y = c(max_y_y, max_x_y))
> # 
> # # Creating straight line between the max values
> # fit <- lm(max_df$y ~ max_df$x)
> # 
> # # Distance from point to line
> # distances <- c()
> # for(i in 1:length(x_values)) {
> #   distances <- c(distances, abs(coef(fit)[2]*x_values[i] - y_values[i] + coef(fit)[1]) / sqrt(coef(fit)[2]^2 + 1^2))
> # }
> # 
> # # Max distance point
> # x_max_dist <- x_values[which.max(distances)]
> # y_max_dist <- y_values[which.max(distances)]
> # 
> # return(c(x_max_dist, y_max_dist))
> #}
> 
> hierarc.str <- function(DAFi_gate_name, n){
+   i <- n
+   pop_pars_v <- vector("character",
+                        n)
+   pop_pars_v[i] <- DAFi_gate_name
+   while(i > 1) {
+     pop_pars_v[i-1] <- strsplit(x =  pop_pars_v[i], 
+                                 split = "_DAFi_",
+                                 fixed = TRUE) %>%
+       .[[1]] %>%
+       tail(.,
+            1) %>%
+       paste0("_DAFi_",
+              .) %>%
+       nchar(.) %>%
+       `-`(nchar(pop_pars_v[i])) %>%
+       abs() %>%
+       substr(x = pop_pars_v[i],
+              start = 1,
+              stop = .)
+     i <- i - 1
+   }
+   return(pop_pars_v %>%
+            unique)
+ }
> 
> sessionInfo()
R version 3.6.2 (2019-12-12)
Platform: x86_64-apple-darwin15.6.0 (64-bit)
Running under: macOS Mojave 10.14.6

Matrix products: default
BLAS:   /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib
LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib

locale:
[1] C

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

other attached packages:
 [1] ggcyto_1.14.1             ncdfFlow_2.32.0          
 [3] BH_1.72.0-3               RcppArmadillo_0.9.900.2.0
 [5] ggplot2_3.3.2             flowCore_1.52.1          
 [7] flowUtils_1.50.0          CytoML_1.12.1            
 [9] flowWorkspace_3.34.1      FlowSOM_1.18.0           
[11] igraph_1.2.5              XML_3.99-0.3             
[13] magrittr_1.5              glue_1.4.1               
[15] Rcpp_1.0.5                gridExtra_2.3            
[17] pheatmap_1.0.12           foreach_1.5.0            
[19] BiocManager_1.30.10      

loaded via a namespace (and not attached):
 [1] Biobase_2.46.0              splines_3.6.2              
 [3] jsonlite_1.7.0              ConsensusClusterPlus_1.50.0
 [5] R.utils_2.9.2               ellipse_0.4.2              
 [7] gtools_3.8.2                RcppParallel_5.0.2         
 [9] stats4_3.6.2                latticeExtra_0.6-29        
[11] RBGL_1.62.1                 yaml_2.2.1                 
[13] robustbase_0.93-6           pillar_1.4.6               
[15] lattice_0.20-38             RUnit_0.4.32               
[17] digest_0.6.25               RColorBrewer_1.1-2         
[19] colorspace_1.4-1            Matrix_1.2-18              
[21] R.oo_1.23.0                 plyr_1.8.6                 
[23] pcaPP_1.9-73                pkgconfig_2.0.3            
[25] tsne_0.1-3                  fda_5.1.5                  
[27] zlibbioc_1.32.0             purrr_0.3.4                
[29] corpcor_1.6.9               mvtnorm_1.1-1              
[31] scales_1.1.1                jpeg_0.1-8.1               
[33] openCyto_1.24.0             flowStats_3.44.0           
[35] tibble_3.0.3                generics_0.0.2             
[37] ellipsis_0.3.1              withr_2.2.0                
[39] flowViz_1.50.0              BiocGenerics_0.32.0        
[41] hexbin_1.28.1               mnormt_1.5-6               
[43] crayon_1.3.4                IDPmisc_1.1.20             
[45] mclust_5.4.6                ks_1.11.7                  
[47] R.methodsS3_1.8.0           MASS_7.3-51.4              
[49] graph_1.64.0                tools_3.6.2                
[51] data.table_1.12.8           flowClust_3.24.0           
[53] lifecycle_0.2.0             matrixStats_0.56.0         
[55] stringr_1.4.0               munsell_0.5.0              
[57] cluster_2.1.0               compiler_3.6.2             
[59] rlang_0.4.7                 grid_3.6.2                 
[61] iterators_1.0.12            base64enc_0.1-3            
[63] gtable_0.3.0                codetools_0.2-16           
[65] rrcov_1.5-2                 R6_2.4.1                   
[67] dplyr_1.0.0                 clue_0.3-57                
[69] KernSmooth_2.23-16          Rgraphviz_2.30.0           
[71] stringi_1.4.6               parallel_3.6.2             
[73] vctrs_0.3.2                 png_0.1-7                  
[75] DEoptimR_1.0-8              tidyselect_1.1.0           
> 
> # create R objects with FJ options
> fj_data_file_path <- "/Users/milanezdelimap/Box/TsangLab/users/PedroMilanezAlmeida/code/DAFi/20-Apr-2020/ezDAFi/T4  Monogenic-disease-HC_038-010.CD8+CD4-.ExtNode.csv"
> fj_data_file_path
[1] "/Users/milanezdelimap/Box/TsangLab/users/PedroMilanezAlmeida/code/DAFi/20-Apr-2020/ezDAFi/T4  Monogenic-disease-HC_038-010.CD8+CD4-.ExtNode.csv"
> batch_mode <- FALSE
> batch_mode
[1] FALSE
> #fj_par_apply_on_prev <- "None"
> #fj_par_apply_on_prev
> popOfInt <- "CD8+ CD4-"
> popOfInt
[1] "CD8+ CD4-"
> minPopSize <- 50
> minPopSize
[1] 50
> wspDir <- "/Users/milanezdelimap/Box/TsangLab/users/PedroMilanezAlmeida/code/DAFi"
> wspDir
[1] "/Users/milanezdelimap/Box/TsangLab/users/PedroMilanezAlmeida/code/DAFi"
> wspName <- "20-Apr-2020.wsp"
> wspName
[1] "20-Apr-2020.wsp"
> #parNames <- c("FJComp-R710-A","FJComp-R780-A","FJComp-V450-A","FJComp-V545-A","FJComp-V605-A","FJComp-V655-A","FJComp-V800-A","FJComp-G610-A","FJComp-B515-A","FJComp-B710-A","FJComp-R660-A","FJComp-G560-A","FJComp-G660-A","FJComp-G710-A","FJComp-G780-A")
> #parNames
> #fj_par_scale <- FJ_PAR_SCALE
> fj_par_scale <- TRUE
> fj_par_scale
[1] TRUE
> fj_par_som <- TRUE
> fj_par_som
[1] TRUE
> #fj_par_xdim <- 10 ### fj_par_xdim AND fj_par_ydim are defined dynamically with pop size
> #fj_par_xdim
> #fj_par_ydim <- 10
> #fj_par_ydim
> fj_csv_ouput_file <- "/Users/milanezdelimap/Box/TsangLab/users/PedroMilanezAlmeida/code/DAFi/20-Apr-2020/ezDAFi/1596139277575/T4__Monogenic-disease-HC_038-010.CD8+CD4-.csv.ezDAFi.csv"
> fj_csv_ouput_file
[1] "/Users/milanezdelimap/Box/TsangLab/users/PedroMilanezAlmeida/code/DAFi/20-Apr-2020/ezDAFi/1596139277575/T4__Monogenic-disease-HC_038-010.CD8+CD4-.csv.ezDAFi.csv"
> fj_output_folder <- "/Users/milanezdelimap/Box/TsangLab/users/PedroMilanezAlmeida/code/DAFi/20-Apr-2020/ezDAFi/1596139277575"
> fj_output_folder
[1] "/Users/milanezdelimap/Box/TsangLab/users/PedroMilanezAlmeida/code/DAFi/20-Apr-2020/ezDAFi/1596139277575"
> fj_par_children <- FALSE
> fj_sample_node_name <- "T4  Monogenic-disease-HC_038-010.fcs"
> fj_population_name <- "CD8+ CD4-"
> fj_transform <- TRUE
> fj_millis_time <- "1596139277575"
> plotDir <- paste0(wspDir,
+                   "/",
+                   wspName,
+                   "_DAFi_plots")
> statsDir <- paste0(wspDir,
+                    "/",
+                    wspName,
+                    "_DAFi_stats")
> #min.nPar <- 1
> #if(min.nPar == 1) {
> #  min.nPar <- 2
> #}
> #min.nPar <- ifelse(min.nPar < 3,
> #                   yes = 3,
> #                  no = min.nPar)
> max.nPar <- 3
> #if(max.nPar < min.nPar) {
> #  max.nPar <- min.nPar
> #}
> fj_plot_stats <- FALSE
> # avoid issue with large numbers of centroids and small minPopSize
> #if(minPopSize < fj_par_xdim * fj_par_ydim) {
> #  minPopSize <- (fj_par_xdim * fj_par_ydim) + 1
> #}
> 
> ## Code to read gates from wsp file
> #load wsp file
> wspName <- paste0(wspDir, 
+                   "/",
+                   wspName)
> wspName
[1] "/Users/milanezdelimap/Box/TsangLab/users/PedroMilanezAlmeida/code/DAFi/20-Apr-2020.wsp"
> ws <- CytoML::open_flowjo_xml(wspName)
> 
> ##find raw .fcs files
> #find path of all fcs files in workspace
> sampleFCS_paths <- XML::xpathApply(ws@doc,
+                                    file.path("/Workspace/SampleList/Sample","DataSet"),
+                                    function(x)
+                                      XML::xmlGetAttr(x,"uri") %>%
+                                      gsub(pattern = "%20", replacement = " ", x = .) %>%
+                                      gsub(pattern = "file:", replacement = "", x = .)) %>%
+   unlist
> sampleFCS_paths
[1] "/Users/milanezdelimap/OneDrive - National Institutes of Health/DAFi/code/DAFi/FCS/T4  Monogenic-disease-HC_036-003.fcs"
[2] "/Users/milanezdelimap/OneDrive - National Institutes of Health/DAFi/code/DAFi/FCS/T4  Monogenic-disease-HC_038-010.fcs"
[3] "/Users/milanezdelimap/OneDrive - National Institutes of Health/DAFi/code/DAFi/FCS/T4  Monogenic-disease-HC_039-003.fcs"
> 
> sampleFCS_names <- sampleFCS_paths %>%
+   basename(.) %>%
+   gsub(pattern = ".fcs",
+        replacement = "",
+        x = .)
> sampleFCS_names
[1] "T4  Monogenic-disease-HC_036-003" "T4  Monogenic-disease-HC_038-010"
[3] "T4  Monogenic-disease-HC_039-003"
> #find name of fcs file used here
> nameSearch <- sapply(sampleFCS_names,
+                      function(name)
+                        grep(pattern = name,
+                             x = basename(fj_data_file_path),
+                             fixed = TRUE)) %>%
+   unlist(.)
> nameSearch
T4  Monogenic-disease-HC_038-010 
                               1 
> nameSearchRes <- names(nameSearch)[nameSearch %>%
+                                      names(.) %>% 
+                                      nchar(.) %>% 
+                                      which.max(.)]
> nameSearchRes
[1] "T4  Monogenic-disease-HC_038-010"
> sampleFCS <- paste0(nameSearchRes,
+                     ".fcs")
> sampleFCS
[1] "T4  Monogenic-disease-HC_038-010.fcs"
> 
> sampleFCS_path <- sampleFCS_paths[basename(sampleFCS_paths) == sampleFCS]
> sampleFCS_path
[1] "/Users/milanezdelimap/OneDrive - National Institutes of Health/DAFi/code/DAFi/FCS/T4  Monogenic-disease-HC_038-010.fcs"
> 
> sampleID_doc <- which(sampleFCS_paths == sampleFCS_path)
> sampleID_doc
[1] 2
> 
> # the following is meant to add support for acs files on windows
> # TODO: test on Mac!
> nchar_wspDir <- nchar(wspDir)
> wspDir_last4 <- substr(wspDir, 
+                        nchar_wspDir - 4 + 1,
+                        nchar_wspDir)
> if(wspDir_last4 != ".acs" & Sys.info()["sysname"] == "Windows") {
+   if(!batch_mode){
+     sampleFCS_path <- substring(sampleFCS_path, 2)
+   } else {
+     sampleFCS_paths <- substring(sampleFCS_paths, 2)
+   }
+ }
> 
> if(wspDir_last4 == ".acs"){
+   if(!batch_mode){
+     sampleFCS_path <- paste0(wspDir,
+                              "/",
+                              sampleFCS_path)
+   } else {
+     sampleFCS_paths <- paste0(wspDir,
+                               "/",
+                               sampleFCS_paths)
+   }
+ }
> 
> #parse wsp and fcs files into a GatingSet object
> if(!batch_mode) {
+   pathFCS <- tryCatch({
+     data.frame(sampleID = CytoML::fj_ws_get_samples(ws)$sampleID[sampleID_doc],
+                file = sampleFCS_path)
+   },
+   error = function(e) {
+     data.frame(sampleID = CytoML::fj_ws_get_samples(ws,
+                                                     sampNloc = "sampleNode")$sampleID[sampleID_doc],
+                file = sampleFCS_path)
+   })
+ } else {
+   pathFCS <- tryCatch({
+     data.frame(sampleID = CytoML::fj_ws_get_samples(ws)$sampleID,
+                file = sampleFCS_paths)
+   },
+   error = function(e){
+     data.frame(sampleID = CytoML::fj_ws_get_samples(ws,
+                                                     sampNloc = "sampleNode")$sampleID,
+                file = sampleFCS_paths)
+   })
+   
+ }
> pathFCS$sampleID <- as.numeric(pathFCS$sampleID)
> pathFCS
  sampleID
1        2
                                                                                                                    file
1 /Users/milanezdelimap/OneDrive - National Institutes of Health/DAFi/code/DAFi/FCS/T4  Monogenic-disease-HC_038-010.fcs
> 
> if(!batch_mode) {
+   gs <- tryCatch({
+     CytoML::flowjo_to_gatingset(ws,
+                                 name = 1,
+                                 path = pathFCS,
+                                 isNcdf = FALSE,
+                                 transform = fj_transform)
+   },
+   error = function(e){
+     CytoML::flowjo_to_gatingset(ws,
+                                 name = 1,
+                                 path = pathFCS,
+                                 isNcdf = FALSE,
+                                 transform = fj_transform,
+                                 sampNloc = "sampleNode")
+   })
+ } else {
+   gs <- tryCatch({
+     CytoML::flowjo_to_gatingset(ws,
+                                 name = 1,
+                                 path = pathFCS,
+                                 isNcdf = TRUE,
+                                 transform = fj_transform)
+   },
+   error = function(e){
+     CytoML::flowjo_to_gatingset(ws,
+                                 name = 1,
+                                 path = pathFCS,
+                                 isNcdf = TRUE,
+                                 transform = fj_transform,
+                                 sampNloc = "sampleNode")
+   })
+ }
Parsing 1 samples
windows version of flowJo workspace recognized.
version X
Creating flowSet...
loading data: /Users/milanezdelimap/OneDrive - National Institutes of Health/DAFi/code/DAFi/FCS/T4  Monogenic-disease-HC_038-010.fcs
Compensating
gating ...
done!
> 
> ### THIS FOLLOWING CODE IS SHUT OFF
> ### IT INTENDS TO ALLOW THE USER TO RUN DAFi ON PREVIOUSLY DAFi-ed POPS
> ### ALTHOUGH IT IS POSSIBLE TO RECOVER DAFi GATES FROM DERIVED PARAMETERS CSV FILES,
> ### IT IS NOT CURRENTLY POSSIBLE TO PARSE THE GATING TREE DOWN THE DAFi GATE
> ### :'(((
> if(FALSE){
+   #### flowworkspace won't load gates based on derived parameters
+   ### therefore trying to do it manually here
+   ## find derived parameter files
+   der.par.paths <- XML::xpathApply(ws@doc,
+                                    file.path("/Workspace/SampleList/Sample/DerivedParameters","DerivedParameter"),
+                                    function(x)
+                                      XML::xmlGetAttr(x, "importFile") %>%
+                                      gsub(pattern = "%20", replacement = " ", x = .) %>%
+                                      gsub(pattern = "file:", replacement = "", x = .)) %>%
+     unlist %>%
+     unique %>%
+     grep(pattern = paste0(gsub(x = basename(as.character(pathFCS$file)),
+                                pattern = ".fcs$",
+                                replacement = "",
+                                fixed = FALSE),
+                           ".EPA.2.csv.EPA.csv"),
+          fixed = TRUE,
+          value = TRUE,
+          x = .)
+   der.par.paths
+   
+   # read DAFi derived parameter csv file and get DAFi gate names
+   der.par.gate.names <- sapply(seq_along(der.par.paths),
+                                function(der.par.path)
+                                  read.csv(file = der.par.path, 
+                                           header = FALSE, 
+                                           stringsAsFactors = FALSE, 
+                                           nrows = 1)[1,])
+   der.par.gate.names
+   # read DAFi derived parameter csv file and get DAFi gates as logical gates
+   der.par.gates <- lapply(seq_along(der.par.gate.names),
+                           function(der.par.gate.idx) {
+                             colClasses <- rep("NULL", length(der.par.gate.idx))
+                             colClasses[der.par.gate.idx] <- "numeric"
+                             der.par.gates <-
+                               read.csv(file = der.par.paths, 
+                                        header = FALSE, 
+                                        stringsAsFactors = FALSE,
+                                        skip = 1,
+                                        colClasses = colClasses)[,1]
+                             der.par.gates <- 
+                               ifelse(der.par.gates > 5e4,
+                                      yes = TRUE,
+                                      no = FALSE)
+                             return(der.par.gates)
+                           })
+   names(der.par.gates) <- der.par.gate.names
+   der.par.gates
+   # find names of population DAFi was called on
+   der.par.first.pop <- strsplit(x = names(der.par.gates),
+                                 split = "_DAFi_",
+                                 fixed = TRUE) %>%
+     lapply(., `[[`, 1)
+   names(der.par.first.pop) <- names(der.par.gates)
+   der.par.first.pop
+   # add DAFi logical gates from derived param file to GatingStrategy
+   for(der.par.gate in names(der.par.gates)) {
+     ls.der.par.gate <- list(der.par.gates[[der.par.gate]])
+     names(ls.der.par.gate) <- sampleNames(gs)
+     flowWorkspace::gs_pop_add(gs = gs,
+                               gate = ls.der.par.gate,
+                               parent = der.par.first.pop[[der.par.gate]],
+                               name = der.par.gate)
+   }
+   
+   
+   flowWorkspace::recompute(gs)
+   
+ }
> 
> flowCore::fsApply(flowWorkspace::gs_pop_get_data(gs), 
+                   print)
flowFrame object 'T4  Monogenic-disease-HC_038-010.fcs_224481'
with 224481 cells and 20 observables:
            name      desc       range minRange    maxRange
$P1        FSC-A      <NA> 262143.0000  0.00000 262143.0000
$P2        FSC-H      <NA> 262143.0000  0.00000 262143.0000
$P3        SSC-A      <NA> 262143.0000  0.00000 262143.0000
$P4        SSC-H      <NA> 262143.0000  0.00000 262143.0000
$P5  Comp-R710-A     CD197    206.2144 50.70029    256.9146
$P6  Comp-R780-A       CD3    206.2144 50.70029    256.9146
$P7  Comp-V450-A       CD4    206.2144 50.70029    256.9146
$P8  Comp-V545-A Viability    206.2144 50.70029    256.9146
$P9  Comp-V605-A       CD8    206.2144 50.70029    256.9146
$P10 Comp-V655-A      CD27    206.2144 50.70029    256.9146
$P11 Comp-V800-A      CD45    206.2144 50.70029    256.9146
$P12 Comp-G610-A   CD45-RA    206.2144 50.70029    256.9146
$P13 Comp-B515-A     CD183    206.2144 50.70029    256.9146
$P14 Comp-B710-A     CD196    206.2144 50.70029    256.9146
$P15 Comp-R660-A     CD185    206.2144 50.70029    256.9146
$P16 Comp-G560-A     CD278    206.2144 50.70029    256.9146
$P17 Comp-G660-A     CD127    206.2144 50.70029    256.9146
$P18 Comp-G710-A      CD25    206.2144 50.70029    256.9146
$P19 Comp-G780-A     CD279    206.2144 50.70029    256.9146
$P20        Time      <NA>     47.9810  0.55200     48.5330
298 keywords are stored in the 'description' slot
A flowSet with 1 experiments.

  column names:
  FSC-A FSC-H SSC-A SSC-H Comp-R710-A Comp-R780-A Comp-V450-A Comp-V545-A Comp-V605-A Comp-V655-A Comp-V800-A Comp-G610-A Comp-B515-A Comp-B710-A Comp-R660-A Comp-G560-A Comp-G660-A Comp-G710-A Comp-G780-A Time
> 
> pData.asDF <- flowCore::parameters(gh_pop_get_data(gs[[1]])) %>%
+   flowCore::pData()
> 
> ## In CSV files, the parameter names are often like FJComp-xxx while in parNames we may be getting Comp-dsfdsdxxx
> #FJCompToComp <- function(char_vec) {
> # if (any(grepl("FJComp", char_vec))) {
> #   ## If it looks like there is FJComp-xxx in parNames but no FJComp-xxx in the column names of the FCS file, then
> #   ## rename FJComp-xxx to Comp-xxx in the parNames and we will be looking for those instead.
> #   new_char_vec <- gsub("^\\FJComp-", "Comp-", char_vec)
> #   return(new_char_vec)
> # } else {
> #   return(char_vec)
> # }
> #}
> #changeFJSpecialChar <- function(char_vec, cor_char_vec) {
> # new_char_vec <- unlist(lapply(char_vec, function(name) {
> #   if (name %in% cor_char_vec | name == "EventNumberDP") {
> #     name
> #   } else {
> #     # Let's try [] to <>
> #     name2 <- gsub("[", "<", name, fixed=TRUE)
> #     name2 <- gsub("]", ">", name2, fixed=TRUE)
> #     if (name2 %in% cor_char_vec) {
> #       name2 # Worked, return it
> #     } else {
> #       # Previous fix did not do it, _ => / on the original names
> #       name2 <- gsub("_", "/", name, fixed=TRUE)
> #       if (name2 %in% cor_char_vec) {
> #         name2 # Worked, return it
> #       } else {
> #         # That did not work either, let's try both [] => on top of the previous fix (_ => /)
> #         name3 <- gsub("[", "<", name2, fixed=TRUE)
> #         name3 <- gsub("]", ">", name3, fixed=TRUE)
> #         if (name3 %in% cor_char_vec) {
> #           name3 # Worked, finally, return it
> #         } else {
> #           ## Maybe we read a wrong dataset?
> #           cat(paste("The input FCS file does not contain the provided input parameter, missing", name, "\n"))
> #           "MISSINGPARAMETER"
> #         }
> #       }
> #     }
> #   }
> # }))
> # return(new_char_vec)
> #}
> 
> # if the fcs was exported from FlowJo, it usually starts with "FJComp-"
> # in such cases, there is no need to change parNames since it orig.parNames already
> # has "FJComp-" in the begining of parameters names
> #if(!grepl(pattern = "^FJComp-",
> #         orig.parNames,
> #         fixed = FALSE) %>%
> #  any) {
> # parNames <- FJCompToComp(parNames)
> #}
> #parNames <- changeFJSpecialChar(parNames, orig.parNames)
> 
> #if(grepl(pattern = "time", 
> #        x = parNames, 
> #        ignore.case = TRUE, 
> #        fixed = FALSE) %>%
> #  any(.)){
> # stop("Please remove time as parameter for  clustering.")
> #}
> 
> #if(grepl(pattern = "FSC|SSC", 
> #        x = parNames, 
> #        ignore.case = FALSE, 
> #        fixed = FALSE) %>%
> #  any(.) &
> #  !fj_par_scale){
> # stop("\n  It seems that FSC and/or SSC were included as clustering parameter, but with no data scaling.\n  FSC/SSC are handled differently than fluorochrome data in FlowJo.\n Please select scaling to make sure all data used in clustering is on the same scale.")
> #}
> 
> #parIndices <- match(parNames, orig.parNames)
> 
> #if (length(parNames) == 0 || length(parIndices) == 0){
> # stop("Something seems wrong, it's like the input FCS file does not contain the provided input parameters.", call.=FALSE)
> #}
> 
> eventsCount <- flowWorkspace::gh_pop_get_data(gs[[1]]) %>%
+   dim %>%
+   .[1]
> 
> #if (length(parNames) == 0){
> # stop("Some input parameters need to be selected!", call.=FALSE)
> #}
> #if (length(parNames) == 0 || "MISSINGPARAMETER" %in% parNames){
> # stop("The input file is missing some of the specified parameters.", call.=FALSE)
> #}
> if (eventsCount == 0){
+   stop("R failed to read the input file.", call.=FALSE)
+ }
> 
> #define gates of the selected samples that will be used here
> if(batch_mode){
+   gates_of_sel_sample <- flowWorkspace::gh_get_pop_paths(gs[[CytoML::fj_ws_get_samples(ws)$sampleID[sampleID_doc]]])
+ } else {
+   gates_of_sel_sample <- flowWorkspace::gh_get_pop_paths(gs[[1]])
+ }
> popOfInt_full_path <- gates_of_sel_sample[
+   basename(gates_of_sel_sample) %in%
+     popOfInt]
> 
> #get info about gating hierarchy for each pop of interest
> names_gates_SOM <- foreach::foreach(pop = seq_along(basename(popOfInt_full_path))) %do% {
+   strsplit(x = gates_of_sel_sample[
+     grepl(pattern = paste0("/",
+                            basename(popOfInt_full_path)[pop],
+                            "/"),
+           x = gates_of_sel_sample,
+           fixed = TRUE)],
+     split = paste0(gates_of_sel_sample[
+       grepl(pattern = paste0("/",
+                              basename(popOfInt_full_path)[pop],
+                              "$"),
+             x = gates_of_sel_sample,
+             fixed = FALSE)][1],
+       "/"),
+     fixed = TRUE) %>%
+     lapply(tail, 1) %>%
+     unlist
+ }
> names(names_gates_SOM) <- basename(popOfInt_full_path)
> names_gates_SOM
$`CD8+ CD4-`
[1] "/FSC-A, Viability subset/FSC-A, SSC-A subset/Single Cells/CD3, CD45 subset/CD8+ CD4-/CD127+"              
[2] "/FSC-A, Viability subset/FSC-A, SSC-A subset/Single Cells/CD3, CD45 subset/CD8+ CD4-/CD197, CD127 subset" 
[3] "/FSC-A, Viability subset/FSC-A, SSC-A subset/Single Cells/CD3, CD45 subset/CD8+ CD4-/Q1: CD45-RA- , CD27+"
[4] "/FSC-A, Viability subset/FSC-A, SSC-A subset/Single Cells/CD3, CD45 subset/CD8+ CD4-/Q2: CD45-RA+ , CD27+"
[5] "/FSC-A, Viability subset/FSC-A, SSC-A subset/Single Cells/CD3, CD45 subset/CD8+ CD4-/Q3: CD45-RA+ , CD27-"
[6] "/FSC-A, Viability subset/FSC-A, SSC-A subset/Single Cells/CD3, CD45 subset/CD8+ CD4-/Q4: CD45-RA- , CD27-"

> 
> if(length(names_gates_SOM) == 1 &
+    is.null(names_gates_SOM[[1]])) {
+   stop("It looks like the selected population has no children for DAFi to refine. DAFi requires the selected population to have at least one child gate.",
+        call. = FALSE)
+ }
> 
> # TODO: CHANGE CODE TO BE ABLE TO HANDLE WHEN PLUGIN IS CALLED ON ROOT
> if(substr(popOfInt, nchar(popOfInt) - 4 + 1, nchar(popOfInt)) == ".fcs" &
+    popOfInt == sampleFCS){
+   stop("The plugin cannot handle the root population yet. Please select the next downstream gate from the root and rerun DAFi.",
+        call. = FALSE)
+ }
> 
> #if doing recursive analysis, run whole DAFi process for each
> #non-terminal gate, adding the results to GatingSet as boolean filter
> #importantly, we can still run children only analysis despite these changes, see below
> 
> #find all gates down the gating hierarchy starting from the selected pop
> names_gates_of_int <- foreach::foreach(pop = seq_along(basename(popOfInt_full_path)),
+                                        .final = unlist) %do% {
+                                          gates_of_sel_sample[grepl(pattern = paste0("/",
+                                                                                     basename(popOfInt_full_path)[pop],
+                                                                                     "/"),
+                                                                    x = gates_of_sel_sample,
+                                                                    fixed = TRUE)]
+                                        }
> 
> #find non-terminal gates down the gating hierarchy, which will all be used in clustering
> names_gates_non_term <- unlist(names_gates_of_int,
+                                use.names = FALSE)[
+                                  lapply(unlist(names_gates_of_int,
+                                                use.names = FALSE),
+                                         function(gate_of_int)
+                                           grepl(pattern = paste0("/",
+                                                                  basename(gate_of_int),
+                                                                  "/"),
+                                                 x = unlist(names_gates_of_int, use.names = FALSE),
+                                                 fixed = TRUE) %>%
+                                           any) %>%
+                                    unlist
+                                  ]
> #change names of non-terminal gates to reflect the fact they will be DAFi-refined
> names_gates_non_term_to_SOM <- as.list(names_gates_non_term)
> 
> names(names_gates_non_term_to_SOM) <-  unlist(names_gates_non_term_to_SOM,
+                                               use.names = FALSE) %>%
+   gsub(pattern = popOfInt_full_path,
+        replacement = "",
+        x = .,
+        fixed = TRUE) %>%
+   strsplit(.,
+            split = "/") %>%
+   lapply(.,
+          function(pop)
+            pop[-1]  %>%
+            gsub(pattern = "^/",
+                 replacement = "",
+                 x = .) %>%
+            paste0("ezDAFi_",
+                   .) %>%
+            paste0(.,
+                   collapse = "/") %>%
+            paste0(popOfInt_full_path,
+                   "/",
+                   .)) %>%
+   unlist(.)
> #gates that will be used in clustering and whose children will be refined
> names_gates_to_SOM <- c(popOfInt_full_path,
+                         names_gates_non_term_to_SOM)
> names(names_gates_to_SOM)[1] <- popOfInt_full_path
> #find their position in the hiearchy
> tree_pos_gate_to_SOM <- strsplit(x = unlist(names_gates_to_SOM,
+                                             use.names = FALSE),
+                                  split = "/",
+                                  fixed = TRUE) %>%
+   lapply(length) %>%
+   unlist(.)
> if(fj_par_children &
+    !batch_mode){
+   pops_to_SOM <- names_gates_to_SOM[tree_pos_gate_to_SOM == min(tree_pos_gate_to_SOM)]
+ } else {
+   pops_to_SOM <- names_gates_to_SOM[order(tree_pos_gate_to_SOM)] #order is very important to ensure hierarchy of gates
+ }
> #drop empty gates
> pops_to_SOM <- pops_to_SOM[
+   lapply(pops_to_SOM,
+          function(pop_to_SOM)
+            !identical(pop_to_SOM, character(0))) %>%
+     unlist(., use.names = FALSE)]
> #number of events in each nonDAFi gate
> if(!batch_mode){
+   sapply(pops_to_SOM,
+          function(pop_to_SOM)
+            dim(flowWorkspace::gh_pop_get_data(gs[[1]],
+                                               pop_to_SOM))[1])
+ }
/FSC-A, Viability subset/FSC-A, SSC-A subset/Single Cells/CD3, CD45 subset/CD8+ CD4-.events 
                                                                                      39973 
> #actual DAFi
> for(pop_to_SOM in seq_along(pops_to_SOM)){
+   print("clustering pop:")
+   print(pops_to_SOM[pop_to_SOM] %>%
+           names(.))
+   for(fSample in seq_along(gs)) {
+     if(dim(flowWorkspace::gh_pop_get_data(gs[[fSample]],
+                                           pops_to_SOM[pop_to_SOM] %>%
+                                           names(.)))[1] > minPopSize) {#[,parIndices])[1] > minPopSize) { # in case a subpop is smaller than min #events, SOM is not applied
+       ## Code to read the GatingSet data from each population that will be analyzed with DAFi
+       #if (nchar(fj_par_apply_on_prev) > 5) { ## Expected either "None" or a valid file path
+       #  load(fj_par_apply_on_prev)
+       # fSOM <- FlowSOM::NewData(fSOM, 
+       #                          flowWorkspace::gh_pop_get_data(gs[[fSample]],
+       #                                                               pops_to_SOM[pop_to_SOM] %>%
+       #                                                                 names(.))[,parIndices]);
+       #} else {
+       gates <- basename(
+         flowWorkspace::gh_pop_get_children(
+           gs[[fSample]], 
+           pops_to_SOM[[pop_to_SOM]])
+       )
+       for(gate in gates) {
+         pop.exprs <- flowWorkspace::gh_pop_get_data(
+           gs[[fSample]],
+           pops_to_SOM[[pop_to_SOM]]) %>%
+           flowCore::exprs()
+         colnames(pop.exprs) <- ifelse(
+           is.na(pData.asDF$desc),
+           yes = pData.asDF$name,
+           no = pData.asDF$desc
+         )
+         irrel.par <- grepl(pattern = "^FSC|^SSC|^Time", 
+                            x = colnames(pop.exprs), 
+                            ignore.case = FALSE, 
+                            fixed = FALSE)
+         irrel.par.expr <- pop.exprs[,irrel.par]
+         pop.exprs <- pop.exprs[,!irrel.par]
+         #if(min.nPar >
+         #   dim(pop.exprs)[2]) {
+         # min.nPar <-
+         #   dim(pop.exprs)[2]
+         #}
+         if(max.nPar >
+            dim(pop.exprs)[2]) {
+           max.nPar <-
+             dim(pop.exprs)[2]
+         }
+         # we need the gating parameters since if they're not present we cannot gate the centroids
+         gate_par <- flowWorkspace::gh_pop_get_gate(
+           gs[[fSample]],
+           paste0(pops_to_SOM[[pop_to_SOM]],
+                  "/",
+                  gate))@parameters %>% 
+           names
+         if(max.nPar !=
+            dim(pop.exprs)[2]) {
+           DAFi.nPar <- max.nPar + length(gate_par)
+         } else {
+           DAFi.nPar <- max.nPar
+         }
+         gate_par <- ifelse(is.na(pData.asDF$desc[pData.asDF$name %in% gate_par]),
+                            yes = pData.asDF$name[pData.asDF$name %in% gate_par],
+                            no = pData.asDF$desc[pData.asDF$name %in% gate_par])
+         if((!gate_par %in%
+             colnames(pop.exprs)) %>%
+            any) {
+           pop.exprs <- cbind(pop.exprs,
+                              irrel.par.expr[,colnames(irrel.par.expr) %in%
+                                               gate_par])
+           colnames(pop.exprs)[colnames(pop.exprs) == ""] <- 
+             colnames(irrel.par.expr)[colnames(irrel.par.expr) %in%
+                                        gate_par]
+         }
+         # get cells within gate of interest to derive t-stat
+         in.gate <- flowWorkspace::gh_pop_get_indices(
+           gs[[fSample]],
+           paste0(pops_to_SOM[[pop_to_SOM]],
+                  "/",
+                  gate))[
+                    flowWorkspace::gh_pop_get_indices(
+                      gs[[fSample]],
+                      pops_to_SOM[[pop_to_SOM]])
+                    ]
+         if(sum(in.gate) > 10 &
+            sum(!in.gate) > 10) {
+           # rank markers by t-stat absolute value
+           markers.t <- apply(pop.exprs,
+                              2, 
+                              function(marker) 
+                                t.test(marker[in.gate],
+                                       marker[!in.gate],
+                                       var.equal = FALSE)$statistic) %>%
+             abs() %>%
+             sort(decreasing = TRUE)
+           #hist.t <- hist(markers.t,
+           #               breaks = "FD",
+           #              plot = FALSE)
+           #elbow <- elbow_finder(markers.t)[1]
+           #hist.t.threshold <- hist.t$breaks[
+           # which(hist.t$counts == 0)[1] + 1
+           # ]
+           #hist.n <- sum(markers.t > hist.t.threshold)
+           #keep.marker <- min(elbow, 
+           #                   hist.n)
+           #keep.marker <- markers.t[1:keep.marker] %>%
+           #  names
+           #if(min.nPar == 1 &
+           #  max.nPar == 1) {
+             #hist.n <- sum(markers.t > hist.t.threshold)
+             #top.nPar <- markers.t[1:hist.n] %>%
+             #  names
+             #elbow <- elbow_finder(markers.t)[1]
+           # top.nPar <- markers.t[1:elbow] %>%
+           #   names
+           # keep.marker <- c(gate_par, #gating parameters must be included otherwise centroids cannot be gated
+           #                  top.nPar) %>%
+           #   unique()
+           #} else {
+           #keep.marker <- max(min.nPar,
+           #                    elbow)
+           #keep.marker <- min(keep.marker,
+           #                    max.nPar)
+           keep.marker <- DAFi.nPar
+             top.nPar <- markers.t[1:keep.marker] %>%
+               names
+             keep.marker <- c(gate_par, #gating parameters must be included otherwise centroids cannot be gated
+                              top.nPar) %>%
+               unique() %>%
+               .[1:keep.marker]
+           #}
+           if(length(keep.marker) == 1){
+             keep.marker <- c(keep.marker, 
+                              names(markers.t)[2])
+           }
+           #keep.marker <- markers.t[1:keep.marker] %>%
+           #  names
+           keep.marker <- colnames(pop.exprs) %in% 
+             keep.marker
+           print("gate:")
+           print(gate)
+           print("markers t-stat:")
+           print(markers.t)
+           #          plot(markers.t)
+           #print("hist: ")
+           #print(markers.t[markers.t > hist.t.threshold])
+           #print("elbow: ")
+           #print(markers.t[1:elbow])
+         } else { #else call: if there are too few cells in traditional gate
+           keep.marker <- colnames(pop.exprs) %in% 
+             gate_par
+           print("gate:")
+           print(gate)
+           print("markers t-stat: not enough cells to generate t-statistic")
+         }
+         print("used markers: ")
+         print(colnames(pop.exprs)[keep.marker])
+         keep.marker <- ifelse(pData.asDF$desc %in% colnames(pop.exprs)[keep.marker],
+                               yes = pData.asDF$desc %in% colnames(pop.exprs)[keep.marker],
+                               no = pData.asDF$name %in% colnames(pop.exprs)[keep.marker])
+         #pca with markers only
+         #rm(pop.exprs)
+         #pop.exprs.scale <- flowWorkspace::gh_pop_get_data(
+         # gs[[fSample]],
+         # pops_to_SOM[pop_to_SOM] %>%
+         #   names()) %>%
+         # flowCore::exprs() %>%
+         # .[,keep.marker] %>%
+         # scale(center = TRUE, 
+         #       scale = TRUE)
+         #pop.pca <- prcomp(x = flowWorkspace::gh_pop_get_data(
+         # gs[[fSample]],
+         # pops_to_SOM[pop_to_SOM] %>%
+         #   names()) %>%
+         #   flowCore::exprs() %>%
+         #   .[,keep.marker],
+         # center = TRUE,
+         # scale. = TRUE)
+         # print(gate)
+         #        plot(summary(pop.pca)$importance[2,],
+         #            main = gate)
+         #colnames(pop.pca$x) <- paste0("PC", 
+         #                             seq(dim(pop.pca$x)[2]))
+         #ls_pop.pca <- list(pop.pca$x)
+         #names(ls_pop.pca) <- rownames(flowCore::pData(gs[[fSample]]))
+         #create FlowSet with FlowSOM centroids
+         #fS_pop.pca <- lapply(ls_pop.pca,
+         #                    function(sample)
+         #                      flowCore::flowFrame(sample)) %>%
+         # flowCore::flowSet()
+         #fSOM <- FlowSOM::ReadInput(fS_pop.pca,
+         #                          compensate = FALSE,
+         #                          transform = FALSE,
+         #                          scale = FALSE,
+         #                          silent = TRUE)
+         
+         #### PLS ####
+         # Y (in.gate) needs to be updated according to results of DAFi-ing the parent population;
+         # this will be done here by simply applying the manual gate to the DAFi-ed parent as an approximation
+         #DAFi.in.gate <- flowWorkspace::gh_pop_get_indices(
+         #  gs[[fSample]],
+         # paste0(pops_to_SOM[[pop_to_SOM]],
+         #        "/",
+         #        gate))[
+         #          flowWorkspace::gh_pop_get_indices(
+         #            gs[[fSample]],
+         #            pops_to_SOM[pop_to_SOM] %>%
+         #              names(.))
+         #          ]
+         #if(sum(DAFi.in.gate) > 10)
+         #X.df <- data.frame(X = scale(flowWorkspace::gh_pop_get_data(gs[[fSample]],
+         #                                                           pops_to_SOM[pop_to_SOM] %>%
+         #                                                             names(.)) %>%
+         #                              .[,keep.marker] %>%
+         #                              flowCore::exprs(),
+         #                            center = TRUE,
+         #                            scale = TRUE) %>%
+         #                    I(),
+         #                  Y = ((DAFi.in.gate) * 1 ) %>%
+         #                    I())
+         #PLS <- pls::cppls(Y ~ X,
+         #                 ncomp = 2,
+         #                 data = X.df,
+         #                 center = TRUE)
+         #
+         #### number of centroids ####
+         # if the number of cells is larger than 1k, 100 centroids are used;
+         # if the number of cells is between 1000 and 50, the number of centroids is 10x the log of the number of cells
+         if(sum(
+           flowWorkspace::gh_pop_get_indices(gs[[fSample]],
+                                             pops_to_SOM[pop_to_SOM] %>%
+                                             names(.))) > 1000
+         ) { 
+           fj_par_xdim <- 10 # 100 centroids showed consistent results at high speed
+         } else { # for low number of cells, around 1 centroid for 10 cells. minPopSize is 50
+           fj_par_xdim <- sum(
+             flowWorkspace::gh_pop_get_indices(gs[[fSample]],
+                                               pops_to_SOM[pop_to_SOM] %>%
+                                                 names(.))
+           ) %>% 
+             "/"(10) %>%
+             sqrt %>% # number of centroids = (fj_par_xdim) ^ 2
+             floor() # avoid decimals
+         }
+         #### SOM/kmeans ####
+         fSOM <- FlowSOM::ReadInput(
+           flowWorkspace::gh_pop_get_data(gs[[fSample]],
+                                          pops_to_SOM[pop_to_SOM] %>%
+                                            names(.)) %>%
+             .[,keep.marker],
+           compensate = FALSE,
+           transform = FALSE,
+           scale = fj_par_scale,
+           silent = TRUE)
+         #ls_pop.PLS <- PLS$scores %>%
+         #  matrix(ncol = 2, dimnames = list(rownames(PLS$scores),
+         #                                  colnames(PLS$scores))) %>%
+         # list()
+         #names(ls_pop.PLS) <- rownames(flowCore::pData(gs[[fSample]]))
+         #create FlowSet with FlowSOM centroids
+         #fS_pop.PLS <- lapply(ls_pop.PLS,
+         #                    function(sample)
+         #                      flowCore::flowFrame(sample)) %>%
+         # flowCore::flowSet()
+         #fSOM <- FlowSOM::ReadInput(fS_pop.PLS,
+         # compensate = FALSE,
+         # transform = FALSE,
+         # scale = FALSE,
+         # silent = TRUE)
+         if(fj_par_som){ #if user decides to use self-organizing maps but pop is smaller than 1%, use kmeans
+           #if(mean(in.gate) > 0.025) { #use SOM only if pop is more than 1% if cells, otherwise kmeans
+           # Code to generate SOM centroids
+           set.seed(2020)
+           fSOM <- FlowSOM::BuildSOM(fSOM,
+                                     colsToUse = NULL,
+                                     silent = TRUE,
+                                     xdim = fj_par_xdim,
+                                     ydim = fj_par_xdim)
+           # Code to gate flowSOM results
+           # retrieve codes
+           if(fj_par_scale) {
+             codes <- t(apply(fSOM$map$codes,
+                             1,
+                             function(centroid)
+                               centroid *
+                               fSOM$scaled.scale +
+                               fSOM$scaled.center))
+           } else {
+             codes <- fSOM$map$codes
+             }
+         } else { # if the user decides to use kmeans
+           # Code to generate kmeans centroids
+           set.seed(2020)
+           fkMeans <- stats::kmeans(x = fSOM$data,#[,parNames],
+                                    centers = fj_par_xdim*fj_par_xdim,
+                                    iter.max = 100)
+           if(fkMeans$ifault == 4){ # https://stackoverflow.com/a/30055776
+             fkMeans <- stats::kmeans(x = fSOM$data,
+                                      centers = fkMeans$centers,
+                                      iter.max = 100,
+                                      algorithm = "MacQueen")}
+           # Code to gate kmeans results
+           # retrieve codes
+           if(fj_par_scale) {
+            codes <- t(apply(fkMeans$centers,
+                             1,
+                             function(centroid)
+                               centroid *
+                               fSOM$scaled.scale +
+                               fSOM$scaled.center))
+           } else {
+             #codes.pca <- fkMeans$centers
+             codes <- fkMeans$centers
+             }
+         }
+         # old PLS code
+         #codes <- codes %*%
+         # t(PLS$loadings) %>%
+         # apply(.,
+         #       1,
+         #       function(parameter)
+         #         parameter *
+         #         attr(X.df$X, "scaled:scale") +
+         #         attr(X.df$X, "scaled:center")
+         # ) %>%
+         # t
+         #colnames(codes) <- pData.asDF$name[keep.marker]
+         
+         # old PCA code
+         #codes <- t(t(codes.pca %*% 
+         #              t(pop.pca$rotation)) * 
+         #            pop.pca$scale + 
+         #            pop.pca$center)
+         #print(dim(codes))
+         #codes <- codes.pca %*%
+         #diag(pop.pca$d) %*%
+         #t(pop.pca$v) %>%
+         #apply(.,
+         #  1,
+         #  function(parameter)
+         #    parameter *
+         #    attr(pop.exprs.scale, "scaled:scale") +
+         #   attr(pop.exprs.scale, "scaled:center")) %>%
+         #t
+         
+         #### graph-based clustering ####
+         # most of this section is from
+         #http://jef.works/blog/2017/09/13/graph-based-community-detection-for-clustering-analysis/
+         # find nearest neighbors
+         #k <- 10
+         #nn.idx <- RANN::nn2(codes,
+         #                  k = k)$nn.idx
+         # following code is from
+         #https://rdrr.io/github/CamaraLab/STvEA/src/R/seurat_anchor_correction.R
+         # build adjacency matrix
+         #j <- as.numeric(x = t(x = nn.idx))
+         #i <- ((1:length(x = j)) - 1) %/% k + 1
+         #nn.mat <- Matrix::sparseMatrix(i = i,
+         #                             j = j, 
+         #                             x = 1,
+         #                             dims = c(nrow(codes),
+         #                                      nrow(codes)))
+         #rownames(nn.mat) <- colnames(nn.mat) <- seq_len(nrow(codes))
+         #source: https://rpubs.com/nurakawa/spectral-clustering
+         #dg <- Matrix::colSums(nn.mat) # degrees of vertices
+         #graph_laplacian <- diag(dg) - nn.mat
+         #ei <- eigen(graph_laplacian,
+         #           symmetric = TRUE)
+         #ei.vec <- ei$vectors[,(dim(nn.mat)[1] - min.nPar):(dim(nn.mat)[1] - 1)]
+         #spec.clust <- kmeans(x = ei.vec,
+         #                    centers = 20,
+         #                    iter.max = 100)
+         #spec.codes <- apply(codes,
+         #                   2,
+         #                   function(marker)
+         #                     sapply(seq_len(20),
+         #                            function(cluster)
+         #                              mean(marker[spec.clust$cluster == cluster])))
+         #codes <- spec.codes
+         # build and simplify graphs (remove self-loops).
+         #kM.g <- igraph::graph.adjacency(nn.mat, 
+         #                              mode = "undirected")
+         #kM.g <- igraph::simplify(kM.g)
+         #Finally, build communities with short random walks in the graph and update the identity of each single cell based on nearest meta-cell and the results of meta-clustering.
+         #kM.km <- igraph::cluster_walktrap(kM.g)
+         #kM.com <- kM.km$membership
+         #names(kM.com) <- kM.km$names
+         #print(table(kM.com))
+         #V(kM.g)$color <- heat.colors(length(kM.km))[kM.com[names(V(kM.g))]]
+         #codes <- apply(codes,
+         #               2,
+         #               function(marker)
+         #                 sapply(seq_len(length(kM.km)),
+         #                        function(cluster)
+         #                          mean(marker[kM.com == cluster])))
+         
+         #### gate centroids ####
+         ls_fSOM <- list(codes)
+         names(ls_fSOM) <- rownames(flowCore::pData(gs[[fSample]]))
+         #create FlowSet with FlowSOM centroids
+         fS_SOM <- lapply(ls_fSOM,
+                          function(sample)
+                            flowCore::flowFrame(sample)) %>%
+           flowCore::flowSet()
+         flowCore::parameters(fS_SOM[[1]]) <- flowCore::parameters(
+           flowWorkspace::gh_pop_get_data(
+             gs[[fSample]],
+             y = "root")[,keep.marker])#[,parNames][,keep.marker])
+         #create GatingSet with FlowSOM centroids
+         suppressMessages(gs_SOM <- GatingSet(fS_SOM))
+         flowCore::pData(gs_SOM) <- flowCore::pData(gs[[fSample]])
+         #get gates and apply to cluster centroids
+         suppressMessages(
+           flowWorkspace::gs_pop_add(
+             gs_SOM,
+             flowWorkspace::gh_pop_get_gate(
+               gs[[fSample]],
+               paste0(pops_to_SOM[[pop_to_SOM]],
+                      "/", gate))))
+         tryCatch({
+           suppressMessages(flowWorkspace::recompute(gs_SOM))
+         },
+         error = function(e){
+           stop(paste0("It looks like the channel \"",
+                       strsplit(x = e$message, 
+                                split = "\n  ",
+                                fixed = TRUE)[[1]][2] %>%
+                         strsplit(x = ., 
+                                  split = " not found",
+                                  fixed = TRUE) %>% 
+                         .[[1]] %>%
+                         .[1],
+                       "\" has not been selected when the plugin was called although it was used down the gating hiearchy. \nPlease, make sure all flow channels used in the gating tree are selected when calling the plugin."), 
+                call. = FALSE)
+         })
+         #### gate cells based on centroid gating ####
+         ## Code to update assignment of cell identity according to DAFi results
+         #graph_labels <- rep(FALSE,
+         #                   length(kM.km))
+         #graph_labels[flowWorkspace::gh_pop_get_indices(gs_SOM[[1]],
+         #                                              gate)] <- TRUE
+         #
+         #SOM_labels <- graph_labels[kM.com]
+         SOM_labels <- rep(FALSE,
+                           dim(codes)[1])
+         SOM_labels[
+           flowWorkspace::gh_pop_get_indices(gs_SOM[[1]],
+                                             gate)
+           ] <- TRUE
+         #spec_labels <- rep(FALSE,
+         #                  dim(spec.clust$centers)[1])
+         #spec_labels[flowWorkspace::gh_pop_get_indices(gs_SOM[[1]],
+         #                                             gate)] <- TRUE
+         #SOM_labels <- spec_labels[spec.clust$cluster]
+         if(fj_par_som){
+           cell_DAFi_label <- SOM_labels[fSOM$map$mapping[,1]]
+         } else {
+           cell_DAFi_label <- SOM_labels[fkMeans$cluster]
+         }
+         all_cells_DAFi_label <- rep(FALSE,
+                                     length(
+                                       flowWorkspace::gh_pop_get_indices(
+                                         gs[[fSample]],
+                                         y = pops_to_SOM[pop_to_SOM] %>%
+                                           names(.)))
+                                     )
+         all_cells_DAFi_label[
+           flowWorkspace::gh_pop_get_indices(gs[[fSample]],
+                                             y = pops_to_SOM[pop_to_SOM] %>%
+                                               names(.))
+           ] <- cell_DAFi_label
+         all_cells_DAFi_label <- list(all_cells_DAFi_label)
+         names(all_cells_DAFi_label) <- sampleNames(gs[[fSample]])
+         flowWorkspace::gs_pop_add(gs[[fSample]],
+                                   all_cells_DAFi_label,
+                                   parent = pops_to_SOM[pop_to_SOM] %>%
+                                     names(.),
+                                   name = paste0("ezDAFi_", gate) ) %>%
+           gsub(pattern = "^/",
+                replacement = "",
+                x = .)
+         suppressMessages(flowWorkspace::recompute(gs[[fSample]]))
+       }
+     } else {
+       gates <- basename(
+         flowWorkspace::gh_pop_get_children(
+           gs[[fSample]], 
+           pops_to_SOM[[pop_to_SOM]]))
+       for(gate in gates) {
+         flowWorkspace::gs_pop_add(
+           gs[[fSample]],
+           flowWorkspace::gh_pop_get_gate(
+             gs[[fSample]],
+             paste0(pops_to_SOM[[pop_to_SOM]],
+                    "/", 
+                    gate)),
+           parent = pops_to_SOM[pop_to_SOM] %>% 
+             names(.),
+           name = paste0("ezDAFi_",
+                         gate) ) %>%
+           gsub(pattern = "^/",
+                replacement = "",
+                x = .)
+       }
+       suppressMessages(flowWorkspace::recompute(gs[[fSample]]))
+     }
+   }
+ }
[1] "clustering pop:"
[1] "/FSC-A, Viability subset/FSC-A, SSC-A subset/Single Cells/CD3, CD45 subset/CD8+ CD4-"
[1] "gate:"
[1] "CD127+"
[1] "markers t-stat:"
    CD127      CD27       CD8   CD45-RA      CD25      CD45     CD197     CD279 
264.50921  71.02773  66.34181  66.29753  42.78608  39.45090  35.88702  33.05221 
    CD278     CD196     CD183     CD185       CD3 Viability       CD4 
 32.82144  30.32864  27.47494  18.84158  13.97635  11.92314  10.21711 
[1] "used markers: "
[1] "CD8"     "CD27"    "CD45-RA" "CD127"  
[1] "gate:"
[1] "CD197, CD127 subset"
[1] "markers t-stat:"
     CD197      CD127       CD27        CD8      CD183        CD4       CD25 
216.290975  77.416444  35.866638  24.504289  17.723248  14.966511  11.178791 
     CD196      CD278      CD279  Viability       CD45    CD45-RA        CD3 
 10.624071  10.159099  10.135253   7.137707   5.002256   4.647211   2.862951 
     CD185 
  1.156113 
[1] "used markers: "
[1] "CD197" "CD8"   "CD27"  "CD183" "CD127"
[1] "gate:"
[1] "Q1: CD45-RA- , CD27+"
[1] "markers t-stat:"
      CD27    CD45-RA      CD279      CD278      CD127       CD45        CD8 
212.968593 175.718440  94.016054  82.666632  74.059666  68.407211  49.583388 
     CD196        CD3      CD185  Viability      CD183       CD25      CD197 
 39.334716  35.401160  34.354152  29.847148  21.526172  15.997933  15.726256 
       CD4 
  3.935095 
[1] "used markers: "
[1] "CD27"    "CD45-RA" "CD278"   "CD127"   "CD279"  
[1] "gate:"
[1] "Q2: CD45-RA+ , CD27+"
[1] "markers t-stat:"
   CD45-RA       CD27      CD278        CD3        CD8      CD197      CD196 
127.848411  80.552780  32.097964  26.226420  24.307628  23.191085  17.014504 
       CD4      CD127      CD279  Viability      CD185       CD25       CD45 
 14.101450  13.255571  10.611352   9.856729   8.189668   5.666408   5.007043 
     CD183 
  4.034547 
[1] "used markers: "
[1] "CD3"     "CD8"     "CD27"    "CD45-RA" "CD278"  
[1] "gate:"
[1] "Q3: CD45-RA+ , CD27-"
[1] "markers t-stat:"
   CD45-RA       CD27      CD278      CD127      CD279      CD196        CD8 
313.570561 143.969193 110.002140  82.718303  74.762518  62.219754  56.830832 
      CD45      CD185  Viability      CD197      CD183        CD3       CD25 
 56.144214  31.580856  30.079093  29.029275  21.287887  21.121014  16.779475 
       CD4 
  1.767602 
[1] "used markers: "
[1] "CD27"    "CD45-RA" "CD278"   "CD127"   "CD279"  
[1] "gate:"
[1] "Q4: CD45-RA- , CD27-"
[1] "markers t-stat:"
      CD27    CD45-RA      CD278      CD279        CD3      CD196       CD45 
139.080184  53.595198  48.030212  33.204927  32.470131  29.891254  20.811252 
       CD8      CD185        CD4      CD183      CD127  Viability      CD197 
 12.793762  12.193489  10.375069   8.717339   7.556909   7.399538   6.326666 
      CD25 
  4.862302 
[1] "used markers: "
[1] "CD3"     "CD27"    "CD45-RA" "CD278"   "CD279"  
> 
> if(batch_mode){
+   post_DAFi_gates <- flowWorkspace::gh_get_pop_paths(
+     gs[[CytoML::fj_ws_get_samples(ws)$sampleID[sampleID_doc]]])
+ } else {
+   post_DAFi_gates <- flowWorkspace::gh_get_pop_paths(gs[[1]])
+ }
> 
> # Close the flowjo workspace connection
> CytoML::flowjo_ws_close(ws)
> 
> DAFi_nodes <- post_DAFi_gates[
+   grep(pattern = "ezDAFi_",
+        x = basename(post_DAFi_gates),
+        fixed = TRUE)
+   ]
> DAFi_nodes <- DAFi_nodes[grep(pattern = popOfInt,
+                               x = DAFi_nodes,
+                               fixed = TRUE)]
> 
> tree_pos_DAFi_gate_to_SOM <- strsplit(x = DAFi_nodes,
+                                       split = "/",
+                                       fixed = TRUE) %>%
+   lapply(length) %>%
+   unlist(.)
> DAFi_nodes <- DAFi_nodes[order(tree_pos_DAFi_gate_to_SOM)] #order is very important to ensure hierarchy of gates
> 
> nonDAFi_nodes <- gsub(pattern = "ezDAFi_", 
+                       replacement = "",
+                       x = DAFi_nodes,
+                       fixed = TRUE)
> 
> DAFi_leaf_nodes <- post_DAFi_gates[
+   grep(pattern = "ezDAFi_",
+        x = post_DAFi_gates,
+        fixed = TRUE)
+   ]
> DAFi_leaf_nodes <- DAFi_leaf_nodes[grep(pattern = popOfInt,
+                                         x = DAFi_leaf_nodes,
+                                         fixed = TRUE)]
> 
> if(batch_mode){
+   modified.autoplot.GatingSet <- function(object, gate, x = NULL,  y = "SSC-A", bins = 30, axis_inverse_trans = TRUE, stats = "percent", ...){
+     if(missing(gate))
+       stop("Must specifiy 'gate'!")
+     if(is.null(x)){
+       #determine dimensions from gate
+       g <- gh_pop_get_gate(object[[1]], gate[1])
+       params <- parameters(g)
+       nDims <- length(params)
+       if(nDims == 1){
+         x <- params
+         y <- flowWorkspace:::fix_y_axis(gs = object, x = x, y = y)
+       }else{
+         x <- params[1]
+         y <- params[2]
+       }
+     }
+     
+     mapping <- aes_q(x = as.symbol(x), y = as.symbol(y))
+     
+     p <- ggcyto(object, mapping, ...) + geom_hex(bins = bins) + geom_gate(gate)
+     if(stats != "none") {
+       p <- p + geom_stats(type = stats)
+     }
+     p <- p + ggcyto_par_set(limits = "instrument")
+     if(axis_inverse_trans)
+       p <- p + axis_x_inverse_trans() + axis_y_inverse_trans()
+     p
+     
+   }
+   
+   modified.autoplot.GatingHierarchy <- function(object, gate, y = "SSC-A", bool=FALSE
+                                                 , arrange.main = sampleNames(object), arrange=TRUE, merge=TRUE
+                                                 , projections = list()
+                                                 , strip.text = c("parent", "gate")
+                                                 , path = "auto"
+                                                 , ...){
+     strip.text <- match.arg(strip.text)
+     if(missing(gate)){
+       gate <- gs_get_pop_paths(object, path = path)
+       gate <- setdiff(gate,"root")
+     }else if (is.numeric(gate)){
+       gate <- gs_get_pop_paths(object, path = path)[gate]
+     }
+     
+     #match given axis to channel names
+     fr <- gh_pop_get_data(object, use.exprs = FALSE)
+     projections <- lapply(projections, function(thisPrj){
+       sapply(thisPrj, function(thisAxis)getChannelMarker(fr, thisAxis)[["name"]])
+     })
+     
+     
+     plotList <- flowWorkspace:::.mergeGates(object, gate, bool, merge, projections = projections)
+     Objs <- lapply(plotList,function(plotObjs){
+       
+       if(is.list(plotObjs)){
+         gate <- plotObjs[["popIds"]]
+         parent <- plotObjs[["parentId"]]
+         myPrj <- projections[[as.character(gate[1])]]
+         
+       }else{
+         gate <- plotObjs
+         parent <- gs_pop_get_parent(object, gate, path = path)
+         myPrj <- projections[[as.character(gate)]]
+       }
+       
+       
+       if(is.null(myPrj)){
+         p <- modified.autoplot.GatingSet(object, gate, y = y, ...)
+       }else{
+         p <- modified.autoplot.GatingSet(object, gate, x = myPrj[["x"]], y = myPrj[["y"]], ...)
+       }
+       
+       p <- p + guides(fill=FALSE) + labs(title = NULL)
+       myTheme <- theme(axis.title = element_text(color = gray(0.3), size = 8)
+                        , axis.text = element_text(color = gray(0.3), size = 6)
+                        , strip.text = element_text(size = 10)
+                        , plot.margin = unit(c(0,0,0,0), "cm")
+                        , panel.spacing = unit(0, "cm")
+       )
+       p <- p + myTheme
+       
+       #rename sample name with parent or current pop name in order to display it in strip
+       
+       if(strip.text == "parent"){
+         popName <- parent
+       }else{
+         popName <- paste(gate, collapse = "|")
+       }
+       attr(p$data, "strip.text") <- popName
+       
+       p
+       
+     })
+     
+     if(arrange){
+       #convert it to a special class to dispatch the dedicated print method
+       Objs <- as(Objs, "ggcyto_GatingLayout")
+       Objs@arrange.main <- arrange.main
+     }
+     
+     Objs
+     
+   }
+   
+   # create subfolder to plot results
+   if(!dir.exists(plotDir)) {
+     dir.create(plotDir)
+   }
+   # create and save plots
+   for(fSample in seq_along(gs)) { # for each sample
+     for(DAFi_leaf_node in DAFi_leaf_nodes){ # for each terminal DAFi node
+       n.up.gates <- (nchar(as.character(DAFi_leaf_node))) - # get the number of gates up the tree for each terminal DAFi node (important later to determine size of PNG file)
+         (nchar(gsub(pattern = "/",
+                     replacement = "",
+                     x =  DAFi_leaf_node,
+                     fixed = TRUE)))
+       png(paste0(plotDir,
+                  "/backgating_",
+                  basename(DAFi_leaf_node),
+                  "_for_",
+                  sampleNames(gs[[fSample]]),
+                  ".png"),
+           width = 4 * n.up.gates %>%
+             sqrt(.) %>% 
+             floor(.) * 300,
+           height = 3 * n.up.gates %>%
+             sqrt(.) %>% 
+             ceiling(.) * 300,
+           res = 300)
+       print(
+         modified.autoplot.GatingHierarchy(gs[[fSample]],
+                                           bins = 256,
+                                           stats = "none",
+                                           strip.text = "parent",
+                                           arrange.main = paste0("Sample: ", 
+                                                                 sampleNames(gs[[fSample]]),
+                                                                 " - Gate: ",
+                                                                 basename(DAFi_leaf_node))) +
+           theme_light() +
+           geom_overlay(DAFi_leaf_node, 
+                        size = 0.1, 
+                        alpha = 1)
+       )
+       dev.off()
+     }
+   }
+   
+   save_gs(gs,
+           path = paste0(wspName,
+                         ".R.gs"),
+           cdf = "move")
+   fileConn <- file(paste0(wspName,
+                           ".R"))
+   writeLines(c("library(foreach)",
+                "library(gridExtra)",
+                "library(magrittr)",
+                "library(XML)",
+                "library(FlowSOM)",
+                "library(flowWorkspace)",
+                "library(CytoML)",
+                "library(flowUtils)",
+                "library(flowCore)",
+                "library(ggcyto)",
+                "",
+                '"============================="',
+                '"Open folder with plots:"',
+                paste0("system2(command =",
+                       '"open"',
+                       ", ",
+                       "args = ",
+                       "\"",
+                       paste0(plotDir),
+                       "\"",
+                       "%>% normalizePath() %>% shQuote()",
+                       ")"),
+                '"============================="',
+                "",
+                '"============================="',
+                '"Load GatingSet with all gates, FCS files and DAFi results:"',
+                paste0("gs <- load_gs(",
+                       "\"",
+                       paste0(wspName,
+                              ".R.gs"),
+                       "\"",
+                       ")"),
+                '"============================="',
+                "",
+                '"============================="',
+                '"Use the loaded packages to explore your data!"',
+                '"For example:"',
+                "ggcyto::autoplot(gs[[1]], bins = 128)",
+                '"============================="'),
+              fileConn)
+   close(fileConn)
+   system2(command = "open",
+           args = paste0(wspName,
+                         ".R") %>%
+             normalizePath(.) %>%
+             shQuote(.))
+ } else {
+   # get logical gate for each DAFi node
+   all_cell_DAFi_label <- foreach::foreach(DAFi_node = DAFi_nodes) %do% {
+     flowWorkspace::gh_pop_get_indices(gs[[1]],
+                                       DAFi_node)
+   }
+   names(all_cell_DAFi_label) <- DAFi_nodes
+   # same for nonDAFi nodes
+   all_cell_nonDAFi_label <- foreach::foreach(nonDAFi_node = nonDAFi_nodes) %do% {
+     flowWorkspace::gh_pop_get_indices(gs[[1]],
+                                       nonDAFi_node)
+   }
+   names(all_cell_nonDAFi_label) <- nonDAFi_nodes
+   
+   # retrieve flowjo cell index
+   EventNumberDP <- read.csv(file = fj_data_file_path,
+                             check.names=FALSE)$EventNumberDP
+   
+   # given flowjo cell index, get whether or not cell is in DAFi node
+   FJ_event_DAFi_label <- foreach::foreach(DAFi_node = DAFi_nodes) %do% {
+     all_cell_DAFi_label[[DAFi_node]][EventNumberDP]
+   }
+   names(FJ_event_DAFi_label) <- DAFi_nodes
+   # same for nonDAFi nodes
+   FJ_event_nonDAFi_label <- foreach::foreach(nonDAFi_node = nonDAFi_nodes) %do% {
+     all_cell_nonDAFi_label[[nonDAFi_node]][EventNumberDP]
+   }
+   names(FJ_event_nonDAFi_label) <- nonDAFi_nodes
+   
+   # extract DAFi gating results to pass back to FlowJo
+   DAFi_labels.ls <- foreach::foreach(DAFi_node = DAFi_nodes) %do% {
+     DAFi_label <- as.matrix(as.integer(FJ_event_DAFi_label[[DAFi_node]]) * 1e5 + 
+                               rnorm(n = length(FJ_event_DAFi_label[[DAFi_node]]),
+                                     mean = 0,
+                                     sd = 1000))
+   }
+   names(DAFi_labels.ls) <- DAFi_nodes
+   # same for nonDAFi nodes
+   nonDAFi_labels.ls <- foreach::foreach(nonDAFi_node = nonDAFi_nodes) %do% {
+     nonDAFi_label <- as.matrix(as.integer(FJ_event_nonDAFi_label[[nonDAFi_node]]) * 1e5 + 
+                                  rnorm(n = length(FJ_event_nonDAFi_label[[nonDAFi_node]]),
+                                        mean = 0,
+                                        sd = 1000))
+   }
+   names(nonDAFi_labels.ls) <- nonDAFi_nodes
+   
+   # get results in right format for CSV (results are only saved in the end of the script!)
+   DAFi_labels <- matrix(
+     unlist(DAFi_labels.ls,
+            use.names = FALSE),
+     ncol = length(DAFi_labels.ls),
+     byrow = FALSE)
+   colnames(DAFi_labels) <- foreach::foreach(DAFi_node = DAFi_nodes,
+                                             .final = unlist) %do% {
+                                               DAFi_node %>%
+                                                 strsplit(x = .,
+                                                          split = popOfInt,
+                                                          fixed = TRUE) %>%
+                                                 .[[1]] %>%
+                                                 tail(.,1) %>%
+                                                 gsub(pattern = "^/",
+                                                      replacement = "",
+                                                      x = .) %>%
+                                                 gsub(pattern = "/",
+                                                      replacement = "_",
+                                                      x = .,
+                                                      fixed = TRUE) %>%
+                                                 gsub(pattern = ",",
+                                                      replacement = ".",
+                                                      x = .,
+                                                      fixed = TRUE) %>%
+                                                 trimws(.,
+                                                        which = "right") %>%
+                                                 paste0(popOfInt,
+                                                        "_",
+                                                        .) %>%
+                                                 gsub(pattern = ",",
+                                                      replacement = ".",
+                                                      x = .,
+                                                      fixed = TRUE)
+                                             }
+   # same for nonDAFi nodes
+   nonDAFi_labels <- matrix(
+     unlist(nonDAFi_labels.ls,
+            use.names = FALSE),
+     ncol = length(nonDAFi_labels.ls),
+     byrow = FALSE)
+   colnames(nonDAFi_labels) <- foreach::foreach(nonDAFi_node = nonDAFi_nodes,
+                                                .final = unlist) %do% {
+                                                  nonDAFi_node %>%
+                                                    strsplit(x = .,
+                                                             split = popOfInt,
+                                                             fixed = TRUE) %>%
+                                                    .[[1]] %>%
+                                                    tail(.,1) %>%
+                                                    gsub(pattern = "^/",
+                                                         replacement = "",
+                                                         x = .) %>%
+                                                    gsub(pattern = "/",
+                                                         replacement = "_",
+                                                         x = .,
+                                                         fixed = TRUE) %>%
+                                                    gsub(pattern = ",",
+                                                         replacement = ".",
+                                                         x = .,
+                                                         fixed = TRUE) %>%
+                                                    trimws(.,
+                                                           which = "right") %>%
+                                                    paste0(popOfInt,
+                                                           "_",
+                                                           .) %>%
+                                                    gsub(pattern = ",",
+                                                         replacement = ".",
+                                                         x = .,
+                                                         fixed = TRUE)
+                                                }
+   
+   #sanity check
+   print(
+     apply(DAFi_labels,
+           2,
+           function(pop)
+             mean(pop > 5e4))
+   )
+   if(fj_plot_stats){
+     #get stats
+     pop.stats.count <- gh_pop_get_stats(gs[[1]],
+                                         type =  "count")
+     pop.stats.percent <- gh_pop_get_stats(gs[[1]],
+                                           type =  "percent")
+     pop.stats.percent$percent <- pop.stats.percent$percent * 100
+     
+     pop.stats.count.DAFi <- pop.stats.count[pop.stats.count$pop %in% 
+                                               DAFi_nodes,]$count
+     names(pop.stats.count.DAFi) <- pop.stats.count[pop.stats.count$pop %in% 
+                                                      DAFi_nodes,]$pop
+     pop.stats.count.DAFi <- data.frame(pop.stats.count.DAFi) %>%
+       t
+     rownames(pop.stats.count.DAFi) <- sampleFCS
+     
+     pop.stats.percent.DAFi <- pop.stats.percent[pop.stats.percent$pop %in% 
+                                                   DAFi_nodes,]$percent
+     names(pop.stats.percent.DAFi) <- pop.stats.percent[pop.stats.percent$pop %in% 
+                                                          DAFi_nodes,]$pop
+     pop.stats.percent.DAFi <- data.frame(pop.stats.percent.DAFi) %>%
+       t
+     rownames(pop.stats.percent.DAFi) <- sampleFCS
+     
+     pop.stats.count.trad <- pop.stats.count[
+       match(gsub(pattern = "ezDAFi_", 
+                  replacement = "",
+                  x = DAFi_nodes,
+                  fixed = TRUE),
+             pop.stats.count$pop),
+       ]$count
+     names(pop.stats.count.trad) <- pop.stats.count[
+       match(gsub(pattern = "ezDAFi_", 
+                  replacement = "",
+                  x = DAFi_nodes,
+                  fixed = TRUE),
+             pop.stats.count$pop),
+       ]$pop
+     pop.stats.count.trad <- data.frame(pop.stats.count.trad) %>%
+       t
+     rownames(pop.stats.count.trad) <- sampleFCS
+     
+     pop.stats.percent.trad <- pop.stats.percent[
+       match(gsub(pattern = "ezDAFi_", 
+                  replacement = "",
+                  x = DAFi_nodes,
+                  fixed = TRUE),
+             pop.stats.count$pop)
+       ,]$percent
+     names(pop.stats.percent.trad) <- pop.stats.percent[
+       match(gsub(pattern = "ezDAFi_", 
+                  replacement = "",
+                  x = DAFi_nodes,
+                  fixed = TRUE),
+             pop.stats.count$pop)
+       ,]$pop
+     pop.stats.percent.trad <- data.frame(pop.stats.percent.trad) %>%
+       t
+     rownames(pop.stats.percent.trad) <- sampleFCS
+     #write stats
+     if(!dir.exists(statsDir)) {
+       dir.create(statsDir)
+     }
+     DAFi.count.file <- paste0(statsDir,
+                               "/",
+                               "ezDAFi_count_",
+                               popOfInt,
+                               ".csv")
+     DAFi.percent.file <- paste0(statsDir,
+                                 "/",
+                                 "ezDAFi_percent_",
+                                 popOfInt,
+                                 ".csv")
+     trad.count.file <- paste0(statsDir,
+                               "/",
+                               "trad_count_",
+                               popOfInt,
+                               ".csv")
+     trad.percent.file <- paste0(statsDir,
+                                 "/",
+                                 "trad_percent_",
+                                 popOfInt,
+                                 ".csv")
+     if(!DAFi.count.file %>%
+        file.exists()) {
+       write.table(x = c("sample",
+                         colnames(pop.stats.count.DAFi)) %>%
+                     t,
+                   append = FALSE,
+                   sep = ",",
+                   file = DAFi.count.file,
+                   row.names = FALSE, 
+                   quote = TRUE,
+                   col.names = FALSE)
+     } else if(
+       !((suppressMessages(
+         read.csv(file = DAFi.count.file,
+                  header = FALSE,
+                  nrows = 1)) %>%
+         unlist(use.names = FALSE) %>%
+         as.character() ==
+         c("sample",
+           colnames(pop.stats.count.DAFi))) %>%
+         all)
+     ) {
+       stop("Either the gates of \"",
+            popOfInt,
+            "\" changed since ezDAFi's last run\nor batch analysis was called on samples with different gating strategies.\nPlease delete stats before rerunning and make sure the same gating\nstrategy is applied to all samples.", 
+            call.=FALSE)
+     }
+     if(!(sampleFCS %in%
+          read.csv(file = DAFi.count.file,
+                   header = TRUE,
+                   colClasses = c("character",
+                                  rep("NULL",
+                                      length(DAFi_nodes))))[,1])) {
+       write.table(x = pop.stats.count.DAFi,
+                   append = TRUE,
+                   sep = ",",
+                   file = DAFi.count.file,
+                   row.names = TRUE, 
+                   quote = TRUE,
+                   col.names = FALSE)
+     } else {
+       sampleFCS.pos <- which(
+         read.csv(file = DAFi.count.file,
+                  header = FALSE,
+                  colClasses = c("character",
+                                 rep("NULL",
+                                     length(DAFi_nodes))))[,1] ==
+           sampleFCS
+       )
+       DAFi.count.df <- read.csv(file = DAFi.count.file,
+                                 header = FALSE,
+                                 skip = 1)
+       colnames(DAFi.count.df) <- c("sample",
+                                    colnames(pop.stats.count.DAFi))
+       DAFi.count.df[(sampleFCS.pos - 1),] <- c(sampleFCS,
+                                                pop.stats.count.DAFi[1,])
+       write.table(x = DAFi.count.df,
+                   append = FALSE,
+                   sep = ",",
+                   file = DAFi.count.file,
+                   row.names = FALSE, 
+                   quote = TRUE,
+                   col.names = TRUE)
+     }
+     if(!DAFi.percent.file %>%
+        file.exists()) {
+       write.table(x = c("sample", 
+                         colnames(pop.stats.percent.DAFi)) %>%
+                     t,
+                   append = FALSE,
+                   sep = ",",
+                   file = DAFi.percent.file,
+                   row.names = FALSE, 
+                   quote = TRUE,
+                   col.names = FALSE)
+     } else if(
+       !((suppressMessages(
+         read.csv(file = DAFi.percent.file,
+                  header = FALSE,
+                  nrows = 1)
+       ) %>%
+       unlist(use.names = FALSE) %>%
+       as.character() ==
+       c("sample",
+         colnames(pop.stats.percent.DAFi))) %>%
+       all)
+     ) {
+       stop("Either the gates of \"",
+            popOfInt,
+            "\" changed since ezDAFi's last run\nor batch analysis was called on samples with different gating strategies.\nPlease delete stats before rerunning and make sure the same gating\nstrategy is applied to all samples.", 
+            call.=FALSE)
+     }
+     if(!(sampleFCS %in%
+          read.csv(file = DAFi.percent.file,
+                   header = TRUE,
+                   colClasses = c("character",
+                                  rep("NULL",
+                                      length(DAFi_nodes))))[,1])) {
+       write.table(x = pop.stats.percent.DAFi,
+                   append = TRUE,
+                   sep = ",",
+                   file = DAFi.percent.file,
+                   row.names = TRUE, 
+                   quote = TRUE,
+                   col.names = FALSE)
+     } else {
+       sampleFCS.pos <- which(
+         read.csv(file = DAFi.percent.file,
+                  header = FALSE,
+                  colClasses = c("character",
+                                 rep("NULL",
+                                     length(DAFi_nodes))))[,1] ==
+           sampleFCS
+       )
+       DAFi.percent.df <- read.csv(file = DAFi.percent.file,
+                                   header = FALSE,
+                                   skip = 1)
+       colnames(DAFi.percent.df) <- c("sample",
+                                      colnames(pop.stats.percent.DAFi))
+       DAFi.percent.df[(sampleFCS.pos - 1),] <- c(sampleFCS,
+                                                  pop.stats.percent.DAFi[1,])
+       write.table(x = DAFi.percent.df,
+                   append = FALSE,
+                   sep = ",",
+                   file = DAFi.percent.file,
+                   row.names = FALSE, 
+                   quote = TRUE,
+                   col.names = TRUE)
+     }
+     if(!trad.count.file %>%
+        file.exists()) {
+       write.table(x = c("sample",
+                         colnames(pop.stats.count.trad)) %>%
+                     t,
+                   append = FALSE,
+                   sep = ",",
+                   file = trad.count.file,
+                   row.names = FALSE, 
+                   quote = TRUE,
+                   col.names = FALSE)
+     } else if(
+       !((suppressMessages(
+         read.csv(file = trad.count.file,
+                  header = FALSE,
+                  nrows = 1)) %>%
+         unlist(use.names = FALSE) %>%
+         as.character() ==
+         c("sample",
+           colnames(pop.stats.count.trad))) %>%
+         all)
+     ) {
+       stop("Either the gates of \"",
+            popOfInt,
+            "\" changed since ezDAFi's last run\nor batch analysis was called on samples with different gating strategies.\nPlease delete stats before rerunning and make sure the same gating\nstrategy is applied to all samples.", 
+            call.=FALSE)
+     }
+     if(!(sampleFCS %in%
+          read.csv(file = trad.count.file,
+                   header = TRUE,
+                   colClasses = c("character",
+                                  rep("NULL",
+                                      length(DAFi_nodes))))[,1])) {
+       write.table(x = pop.stats.count.trad,
+                   append = TRUE,
+                   sep = ",",
+                   file = trad.count.file,
+                   row.names = TRUE, 
+                   quote = TRUE,
+                   col.names = FALSE)
+     } else {
+       sampleFCS.pos <- which(
+         read.csv(file = trad.count.file,
+                  header = FALSE,
+                  colClasses = c("character",
+                                 rep("NULL",
+                                     length(DAFi_nodes))))[,1] ==
+           sampleFCS
+       )
+       trad.count.df <- read.csv(file = trad.count.file,
+                                 header = FALSE,
+                                 skip = 1)
+       colnames(trad.count.df) <- c("sample",
+                                    colnames(pop.stats.count.trad))
+       trad.count.df[(sampleFCS.pos - 1),] <- c(sampleFCS,
+                                                pop.stats.count.trad[1,])
+       write.table(x = trad.count.df,
+                   append = FALSE,
+                   sep = ",",
+                   file = trad.count.file,
+                   row.names = FALSE, 
+                   quote = TRUE,
+                   col.names = TRUE)
+     }
+     if(!trad.percent.file %>%
+        file.exists()) {
+       write.table(x = c("sample",
+                         colnames(pop.stats.percent.trad)) %>%
+                     t,
+                   append = FALSE,
+                   sep = ",",
+                   file = trad.percent.file,
+                   row.names = FALSE, 
+                   quote = TRUE,
+                   col.names = FALSE)
+     } else if(
+       !((suppressMessages(
+         read.csv(file = trad.percent.file,
+                  header = FALSE,
+                  nrows = 1)) %>%
+         unlist(use.names = FALSE) %>%
+         as.character() ==
+         c("sample",
+           colnames(pop.stats.percent.trad))) %>%
+         all)
+     ) {
+       stop("Either the gates of \"",
+            popOfInt,
+            "\" changed since ezDAFi's last run\nor batch analysis was called on samples with different gating strategies.\nPlease delete stats before rerunning and make sure the same gating\nstrategy is applied to all samples.", 
+            call.=FALSE)
+     }
+     if(!(sampleFCS %in%
+          read.csv(file = trad.percent.file,
+                   header = TRUE,
+                   colClasses = c("character",
+                                  rep("NULL",
+                                      length(DAFi_nodes))))[,1])) {
+       write.table(x = pop.stats.percent.trad,
+                   append = TRUE,
+                   sep = ",",
+                   file = trad.percent.file,
+                   row.names = TRUE, 
+                   quote = TRUE,
+                   col.names = FALSE)
+     } else {
+       sampleFCS.pos <- which(
+         read.csv(file = trad.percent.file,
+                  header = FALSE,
+                  colClasses = c("character",
+                                 rep("NULL",
+                                     length(DAFi_nodes))))[,1] ==
+           sampleFCS
+       )
+       trad.percent.df <- read.csv(file = trad.percent.file,
+                                   header = FALSE,
+                                   skip = 1)
+       colnames(trad.percent.df) <- c("sample",
+                                      colnames(pop.stats.percent.trad))
+       trad.percent.df[(sampleFCS.pos - 1),] <- c(sampleFCS,
+                                                  pop.stats.percent.trad[1,])
+       write.table(x = trad.percent.df,
+                   append = FALSE,
+                   sep = ",",
+                   file = trad.percent.file,
+                   row.names = FALSE, 
+                   quote = TRUE,
+                   col.names = TRUE)
+     }
+     
+     # create heatmaps with median expression of all selected paramaters on DAFi vs traditional gates
+     # as well as pseudocolor for the bidimensional gate
+     if(!dir.exists(plotDir)){
+       dir.create(plotDir)
+     }
+     for(DAFi_node in DAFi_nodes) {
+       nonDAFi_node <- gsub(pattern = "ezDAFi_", 
+                            replacement = "",
+                            x = DAFi_node,
+                            fixed = TRUE)
+       gate_par <- flowWorkspace::gh_pop_get_gate(
+         gs[[1]],
+         nonDAFi_node)@parameters %>% 
+         names
+       filtLs <- filterList(gs_pop_get_gate(gs[[1]],
+                                            nonDAFi_node))
+       n.events.DAFi <- (gh_pop_get_indices(gs[[1]],
+                                            DAFi_node) %>%
+                           sum)
+       n.events.trad <- (gh_pop_get_indices(gs[[1]],
+                                            nonDAFi_node) %>%
+                           sum)
+       tryCatch({
+         if(length(gate_par) == 2) {
+           pop.exprs <- rbind(flowWorkspace::gh_pop_get_data(gs[[1]],
+                                                             DAFi_node) %>%
+                                flowCore::exprs() %>%
+                                .[,gate_par],
+                              flowWorkspace::gh_pop_get_data(gs[[1]],
+                                                             nonDAFi_node) %>%
+                                flowCore::exprs() %>%
+                                .[,gate_par]) %>%
+             as.data.frame()
+           pop.exprs$gate.type <- c(rep(paste0("ezDAFi :: ",
+                                               n.events.DAFi,
+                                               " events"),
+                                        n.events.DAFi),
+                                    rep(paste0("manual :: ",
+                                               n.events.trad,
+                                               " events"),
+                                        n.events.trad))
+           xlim.outliers <- (abs(flowWorkspace::gh_pop_get_data(gs[[1]],
+                                                                nonDAFi_node %>%
+                                                                  dirname()) %>%
+                                   flowCore::exprs() %>%
+                                   .[,gate_par[1]] - median(
+                                     flowWorkspace::gh_pop_get_data(gs[[1]],
+                                                                    nonDAFi_node %>%
+                                                                      dirname()) %>%
+                                       flowCore::exprs() %>%
+                                       .[,gate_par[1]]
+                                   )) / mad(
+                                     flowWorkspace::gh_pop_get_data(gs[[1]],
+                                                                    nonDAFi_node %>%
+                                                                      dirname()) %>%
+                                       flowCore::exprs() %>%
+                                       .[,gate_par[1]]
+                                   ))
+           xlim.outliers <- xlim.outliers > quantile(xlim.outliers, prob = 0.999)
+           ylim.outliers <- (abs(flowWorkspace::gh_pop_get_data(gs[[1]],
+                                                                nonDAFi_node %>%
+                                                                  dirname()) %>%
+                                   flowCore::exprs() %>%
+                                   .[,gate_par[2]] - median(
+                                     flowWorkspace::gh_pop_get_data(gs[[1]],
+                                                                    nonDAFi_node %>%
+                                                                      dirname()) %>%
+                                       flowCore::exprs() %>%
+                                       .[,gate_par[2]]
+                                   )) / mad(
+                                     flowWorkspace::gh_pop_get_data(gs[[1]],
+                                                                    nonDAFi_node %>%
+                                                                      dirname()) %>%
+                                       flowCore::exprs() %>%
+                                       .[,gate_par[2]]
+                                   ))
+           ylim.outliers <- ylim.outliers > quantile(ylim.outliers, prob = 0.999)
+           xlim.exprs <- flowWorkspace::gh_pop_get_data(gs[[1]],
+                                                        nonDAFi_node %>%
+                                                          dirname()) %>%
+             flowCore::exprs() %>%
+             .[!xlim.outliers,gate_par[1]] %>%
+             range()
+           ylim.exprs <- flowWorkspace::gh_pop_get_data(gs[[1]],
+                                                        nonDAFi_node %>%
+                                                          dirname()) %>%
+             flowCore::exprs() %>%
+             .[!ylim.outliers,gate_par[2]] %>%
+             range()
+           plot.cells <- suppressMessages(
+             ggplot(pop.exprs, 
+                    aes(x = !!sym(gate_par[1]),
+                        y = !!sym(gate_par[2]))) + 
+               theme_bw() +
+               theme(legend.position = "none",
+                     plot.title = element_text(hjust = 0.5)) +
+               coord_cartesian(xlim = xlim.exprs,
+                               ylim = ylim.exprs) +
+               geom_polygon(data = filtLs, 
+                            fill = NA, 
+                            col = "black") +
+               xlab(ifelse(is.na(pData.asDF[pData.asDF$name %in% 
+                                              gate_par[1],]$desc),
+                           yes = pData.asDF[pData.asDF$name %in% 
+                                              gate_par[1],]$name,
+                           no = pData.asDF[pData.asDF$name %in% 
+                                             gate_par[1],]$desc)) +
+               ylab(ifelse(is.na(pData.asDF[pData.asDF$name %in% 
+                                              gate_par[2],]$desc),
+                           yes = pData.asDF[pData.asDF$name %in% 
+                                              gate_par[2],]$name,
+                           no = pData.asDF[pData.asDF$name %in% 
+                                             gate_par[2],]$desc)) +
+               facet_wrap("gate.type") +
+               ggtitle(paste0(nonDAFi_node %>%
+                                basename(),
+                              "\n",
+                              sampleFCS))
+           )
+           if(!dim(pop.exprs)[1] < 100) {
+             plot.cells <- plot.cells +
+               geom_hex(
+                 binwidth = c((xlim.exprs[2] - xlim.exprs[1])/256,
+                              (ylim.exprs[2] - ylim.exprs[1])/256),
+                 mapping = aes(fill = stat(log(count)))
+               ) +
+               scale_fill_viridis_c(option = "inferno")
+           } else {
+             plot.cells <- plot.cells +
+               geom_point()
+           }
+           ggsave(plot = plot.cells,
+                  filename = paste0(plotDir,
+                                    "/PSEUDOCOLOR.",
+                                    gsub(pattern = "/",
+                                         replacement = "_", 
+                                         x = DAFi_node,
+                                         fixed = TRUE),
+                                    "_",
+                                    sampleFCS,
+                                    ".pdf"),
+                  width = 5,
+                  height = 3)
+         }
+         if(length(gate_par) == 1) {
+           filtLs <- fortify(filtLs)
+           filtLs <- unlist(filtLs[,1], use.names = F)
+           filtLs <- data.frame(x1 = filtLs[1],
+                                xend = filtLs[2],
+                                y1 = 0.5,
+                                yend = 0.5)
+           #        filtLs.v1 <- data.frame(xintercept = filtLs$x1)
+           pop.exprs <- c(flowWorkspace::gh_pop_get_data(gs[[1]],
+                                                         DAFi_node) %>%
+                            flowCore::exprs() %>%
+                            .[,gate_par[1]],
+                          flowWorkspace::gh_pop_get_data(gs[[1]],
+                                                         nonDAFi_node) %>%
+                            flowCore::exprs() %>%
+                            .[,gate_par[1]]) %>%
+             data.frame()
+           colnames(pop.exprs) <- gate_par[1]
+           xlim.outliers <- (abs(flowWorkspace::gh_pop_get_data(gs[[1]],
+                                                                nonDAFi_node %>%
+                                                                  dirname()) %>%
+                                   flowCore::exprs() %>%
+                                   .[,gate_par[1]] - median(
+                                     flowWorkspace::gh_pop_get_data(gs[[1]],
+                                                                    nonDAFi_node %>%
+                                                                      dirname()) %>%
+                                       flowCore::exprs() %>%
+                                       .[,gate_par[1]]
+                                   )) / mad(
+                                     flowWorkspace::gh_pop_get_data(gs[[1]],
+                                                                    nonDAFi_node %>%
+                                                                      dirname()) %>%
+                                       flowCore::exprs() %>%
+                                       .[,gate_par[1]]
+                                   ))
+           xlim.outliers <- xlim.outliers > quantile(xlim.outliers, prob = 0.999)
+           xlim.exprs <- flowWorkspace::gh_pop_get_data(gs[[1]],
+                                                        nonDAFi_node %>%
+                                                          dirname()) %>%
+             flowCore::exprs() %>%
+             .[-xlim.outliers,gate_par[1]] %>%
+             range()
+           pop.exprs$gate.type <- c(rep(paste0("ezDAFi :: ",
+                                               n.events.DAFi,
+                                               " events"),
+                                        n.events.DAFi),
+                                    rep(paste0("manual :: ",
+                                               n.events.trad,
+                                               " events"),
+                                        n.events.trad))
+           plot.cells <- suppressMessages(
+             ggplot(pop.exprs, 
+                    aes(x = !!sym(gate_par[1]))) + 
+               theme_bw() +
+               theme(legend.position = "none",
+                     plot.title = element_text(hjust = 0.5)) +
+               coord_cartesian(xlim = xlim.exprs) +
+               geom_density(fill = "black",
+                            aes(y = ..scaled..)) +
+               xlab(ifelse(is.na(pData.asDF[pData.asDF$name %in% 
+                                              gate_par[1],]$desc),
+                           yes = pData.asDF[pData.asDF$name %in% 
+                                              gate_par[1],]$name,
+                           no = pData.asDF[pData.asDF$name %in% 
+                                             gate_par[1],]$desc)) +
+               facet_wrap("gate.type") +
+               ggtitle(paste0(nonDAFi_node %>%
+                                basename(),
+                              "\n",
+                              sampleFCS))
+           )
+           if(!filtLs$x1 < -1e100) {
+             plot.cells <- plot.cells +
+               geom_vline(xintercept = filtLs$x1,
+                          color = "red")
+           }
+           if(!filtLs$xend > 1e100) {
+             plot.cells <- plot.cells +
+               geom_vline(xintercept = filtLs$xend,
+                          color = "red")
+           }
+           ggsave(plot = plot.cells,
+                  filename = paste0(plotDir,
+                                    "/HISTOGRAM.",
+                                    gsub(pattern = "/",
+                                         replacement = "_", 
+                                         x = DAFi_node,
+                                         fixed = TRUE),
+                                    "_",
+                                    sampleFCS,
+                                    ".pdf"),
+                  width = 5,
+                  height = 3)
+         }
+       },
+       error = function(e)
+         print(paste0("Single cell plot failed for: ",
+                      DAFi_node)))
+       # get median
+       mark.exprs <- cbind(
+         flowWorkspace::gh_pop_get_data(gs[[1]],
+                                        DAFi_node) %>% 
+           flowCore::exprs() %>%
+           apply(2,
+                 median)
+         , 
+         flowWorkspace::gh_pop_get_data(gs[[1]],
+                                        nonDAFi_node) %>%
+           flowCore::exprs() %>%
+           apply(2,
+                 median))
+       mark.exprs <- mark.exprs[!grepl(pattern = "time", 
+                                       x = rownames(mark.exprs), 
+                                       ignore.case = TRUE, 
+                                       fixed = FALSE),]
+       mark.exprs <- mark.exprs[!grepl(pattern = "FSC|SSC", 
+                                       x = rownames(mark.exprs), 
+                                       ignore.case = FALSE, 
+                                       fixed = FALSE),]
+       rownames(mark.exprs) <- pData.asDF$desc[pData.asDF$name %in%
+                                                 rownames(mark.exprs)]
+       tryCatch({
+         mark.exprs %>%
+           .[order(abs(.[,1] - .[,2]),
+                   decreasing = TRUE),] %>%
+           pheatmap(mat = .,
+                    cluster_cols = FALSE,
+                    cluster_rows = FALSE, 
+                    scale = "none",
+                    #               color = hcl.colors(256, 
+                    #                                  palette = "RdYlBu",
+                    #                                 alpha = NULL, 
+                    #                                 rev = FALSE, 
+                    #                                 fixup = TRUE),
+                    labels_col = c("ezDAFi", "manual"),
+                    main = nonDAFi_node %>%
+                      basename(),
+                    filename = paste0(plotDir,
+                                      "/HEATMAP.",
+                                      gsub(pattern = "/",
+                                           replacement = "_", 
+                                           x = DAFi_node,
+                                           fixed = TRUE),
+                                      "_",
+                                      sampleFCS,
+                                      ".pdf"),
+                    width = 3,
+                    height = ifelse(0.25 * dim(.)[1] < 4,
+                                    yes = 4,
+                                    no = 0.25 * dim(.)[1]),
+                    angle_col = 45)},
+         error = function(e)
+           print(paste0("Heatmap failed for: ",
+                        DAFi_node)))
+     }
+   }
+   
+   all.labels.ls <- foreach::foreach(DAFi_node = DAFi_nodes) %do% {
+     all.label <- as.matrix(all_cell_DAFi_label[[DAFi_node]] %>%
+                              as.integer(.))
+   }
+   names(all.labels.ls) <- DAFi_nodes
+   
+   all.labels <- matrix(unlist(all.labels.ls,
+                               use.names = FALSE),
+                        ncol = length(all.labels.ls),
+                        byrow = FALSE)
+   colnames(all.labels) <- foreach::foreach(DAFi_node = DAFi_nodes,
+                                            .final = unlist) %do% {
+                                              DAFi_node %>%
+                                                strsplit(x = .,
+                                                         split = popOfInt,
+                                                         fixed = TRUE) %>%
+                                                .[[1]] %>%
+                                                tail(.,1) %>%
+                                                gsub(pattern = "^/",
+                                                     replacement = "",
+                                                     x = .) %>%
+                                                gsub(pattern = "/",
+                                                     replacement = "_",
+                                                     x = .,
+                                                     fixed = TRUE) %>%
+                                                gsub(pattern = ",",
+                                                     replacement = ".",
+                                                     x = .,
+                                                     fixed = TRUE) %>%
+                                                trimws(.,
+                                                       which = "right") %>%
+                                                paste0(popOfInt,
+                                                       "_",
+                                                       .) %>%
+                                                gsub(pattern = ",",
+                                                     replacement = ".",
+                                                     x = .,
+                                                     fixed = TRUE)
+                                            }
+   #2nd sanity check
+   print(
+     apply(all.labels,
+           2,
+           function(pop)
+             mean(pop > 0))
+   )
+   
+   flowEnv <- new.env()
+   
+   for(pop in seq_along(colnames(all.labels))) {
+     if(!(strsplit(x =  colnames(all.labels)[pop], 
+                   split = "_DAFi_",
+                   fixed = TRUE) %>%
+          .[[1]] %>% 
+          length()) > 2){
+       mat <- matrix(c(5e4, 5e5),
+                     ncol = 1,
+                     dimnames = list(c("min", "max"),
+                                     colnames(all.labels)[pop]))
+       rg <- rectangleGate(filterId = colnames(all.labels)[pop],
+                           .gate = mat)
+       # test if DAFi is not direct child of pop of interest
+       # if it is, add gate directly to flowEnv
+       # if it is a grandchild, get name of DAFi parent and add it to flowEnv hierarchically
+       flowEnv[[as.character(colnames(all.labels)[pop])]] <- rg
+     } else { # from: https://rdrr.io/github/RGLab/CytoML/src/R/gate-methods.R
+       DAFi_gates_v <- hierarc.str(DAFi_gate_name = colnames(all.labels)[pop],
+                                   n = 2)
+       rgs <- vector("list",
+                     length = 2)
+       names(rgs) <- DAFi_gates_v
+       for(DAFi_gate in DAFi_gates_v) {
+         rgs[[as.character(DAFi_gate)]] <- 
+           rectangleGate(filterId = DAFi_gate,
+                         .gate = matrix(c(5e4, 5e5),
+                                        ncol = 1,
+                                        dimnames = list(c("min", "max"),
+                                                        DAFi_gate)))
+         
+       }
+       rgs <- rev(rgs) # parent gate must come later
+       flowEnv[[as.character(colnames(all.labels)[pop])]] <-
+         new("subsetFilter",
+             filterId = colnames(all.labels)[pop], 
+             filters = rgs)
+       
+     }
+   }
+   
+   outputFile <- paste0(fj_output_folder,
+                        "/",
+                        basename(fj_data_file_path),
+                        ".gating-ml2.xml")
+   
+   #############################################
+   ## Code related to writing Gating-ML files ##
+   ##########################################################
+   ## Copied and modified from #############################
+   ## https://rdrr.io/bioc/flowUtils/src/R/writeGatingML.R ##
+   ##########################################################
+   
+   # Write objects in the flowEnv environment to an Gating-ML 2.0 XML file.
+   # If file is NULL then output is written to standard output.
+   modified.write.gatingML <- function(flowEnv, file = NULL)
+   {
+     #THIS FUNCTION HAS BEEN MODIFIED BY A CLUELESS PERSON! DONT TRUST IT TOO MUCH! SOURCE:https://rdrr.io/bioc/flowUtils/src/R/writeGatingML.R
+     
+     if(!is.null(file) && !is(file, "character")) 
+       stop("A file has to be either NULL or a character string.", call. = FALSE)
+     if(is.null(flowEnv) || !is.environment(flowEnv))
+       stop("A flowEnv environment with objects to be saved is requred.", call. = FALSE)
+     if(!is.null(file) && substr(file, nchar(file) - 3, nchar(file)) != ".xml")
+       file <- paste(file, "xml", sep=".")
+     
+     flowEnv[['.debugMessages']] = c()
+     
+     namespaces <- c(
+       "gating" = "http://www.isac-net.org/std/Gating-ML/v2.0/gating", 
+       "xsi" = "http://www.w3.org/2001/XMLSchema-instance", 
+       "transforms" = "http://www.isac-net.org/std/Gating-ML/v2.0/transformations", 
+       "data-type" = "http://www.isac-net.org/std/Gating-ML/v2.0/datatypes")
+     
+     gatingMLNode = suppressWarnings(xmlTree("gating:Gating-ML", namespaces = namespaces, 
+                                             attrs = c("xsi:schemaLocation" = "http://www.isac-net.org/std/Gating-ML/v2.0/gating http://flowcyt.sourceforge.net/gating/2.0/xsd/Gating-ML.v2.0.xsd http://www.isac-net.org/std/Gating-ML/v2.0/transformations http://flowcyt.sourceforge.net/gating/2.0/xsd/Transformations.v2.0.xsd http://www.isac-net.org/std/Gating-ML/v2.0/datatypes http://flowcyt.sourceforge.net/gating/2.0/xsd/DataTypes.v2.0.xsd")))
+     
+     ##### THE FOLLOWING SEVERAL LINES ARE NOT COMMENTED OUT IN THE ORIGINAL
+     #gatingMLNode$addNode("data-type:custom_info", close = FALSE)
+     #gatingMLNode$addNode("info", "Gating-ML 2.0 export generated by R/flowUtils/flowCore")
+     #gatingMLNode$addNode("R-version", sessionInfo()$R.version$version.string)
+     #gatingMLNode$addNode("flowCore-version", as.character(packageVersion("flowCore")))
+     #gatingMLNode$addNode("flowUtils-version", as.character(packageVersion("flowUtils")))
+     #gatingMLNode$addNode("XML-version", as.character(packageVersion("XML")))
+     #gatingMLNode$closeTag()
+     
+     flowEnv[['.objectIDsWrittenToXMLOutput']] = list() # Use this list to collect XML Ids
+     
+     somethingUseful = FALSE
+     for (x in ls(flowEnv)) {
+       object = objectNameToObject(x, flowEnv)
+       if(is(object, "parameterFilter") || is(object, "singleParameterTransform") || is(object, "setOperationFilter"))
+       {
+         somethingUseful = TRUE
+         break
+       }
+     }
+     if(!somethingUseful) warning("Nothing useful seems to be present in the environment; the output Gating-ML file may not be very useful.", call. = FALSE)
+     
+     # Go over everything and temporarily add transformations and argument gates to flowEnv
+     # if they are not saved in flowEnv directly, but they are being used in other objects
+     flowEnv[['.addedObjects']] = list() # List of object identifiers of objects that we have to temporarily add to flowEnv
+     for (x in ls(flowEnv)) addReferencedObjectsToEnv(x, flowEnv) 
+     
+     flowEnv[['.singleParTransforms']] = new.env() # Use this env to collect transformations
+     for (x in ls(flowEnv)) if(is(flowEnv[[x]], "singleParameterTransform")) collectTransform(x, flowEnv)
+     
+     # Transforms go first unless they can be skipped all together
+     for (x in ls(flowEnv)) if(is(flowEnv[[x]], "transform"))
+       if(!shouldTransformationBeSkipped(x, flowEnv)) addObjectToGatingML(gatingMLNode, x, flowEnv)
+     for (x in ls(flowEnv)) if(!is(flowEnv[[x]], "transform")) addObjectToGatingML(gatingMLNode, x, flowEnv)
+     
+     if(!is.null(file)) sink(file = file)
+     cat(saveXML(gatingMLNode$value(), encoding = "UTF-8"))
+     if(!is.null(file)) sink()
+     
+     rm(list = ls(flowEnv[['.singleParTransforms']], all.names = TRUE), envir = flowEnv[['.singleParTransforms']])
+     rm('.singleParTransforms', envir = flowEnv)
+     
+     rm(list = as.character(flowEnv[['.addedObjects']]), envir = flowEnv)
+     rm('.addedObjects', envir = flowEnv)
+     
+     rm('.objectIDsWrittenToXMLOutput', envir = flowEnv) 
+   }
+   
+   # Add the object x to the Gating-ML node
+   addObjectToGatingML <- function(gatingMLNode, x, flowEnv, addParent = NULL, forceGateId = NULL)
+   {
+     if(is(x, "character")) object = flowEnv[[x]]
+     else object = x
+     switch(class(object),
+            "rectangleGate" = addRectangleGateNode(gatingMLNode, x, flowEnv, addParent, forceGateId),
+            "polygonGate" = addPolygonGateNode(gatingMLNode, x, flowEnv, addParent, forceGateId),
+            "ellipsoidGate" = addEllipsoidGateNode(gatingMLNode, x, flowEnv, addParent, forceGateId),
+            "quadGate" = addQuadGateNode(gatingMLNode, x, flowEnv, addParent, forceGateId),
+            "intersectFilter" = addBooleanAndGateNode(gatingMLNode, x, flowEnv, addParent, forceGateId),
+            "unionFilter" = addBooleanOrGateNode(gatingMLNode, x, flowEnv, addParent, forceGateId),
+            "complementFilter" = addBooleanNotGateNode(gatingMLNode, x, flowEnv, addParent, forceGateId),
+            "subsetFilter" = addGateWithParent(gatingMLNode, x, flowEnv),
+            "compensation" = addCompensation(gatingMLNode, x, flowEnv),
+            "asinhtGml2" = addAsinhtGml2(gatingMLNode, x, flowEnv),
+            "hyperlogtGml2" = addHyperlogtGml2(gatingMLNode, x, flowEnv),
+            "lintGml2" = addLintGml2(gatingMLNode, x, flowEnv),
+            "logtGml2" = addLogtGml2(gatingMLNode, x, flowEnv),
+            "logicletGml2" = addLogicletGml2(gatingMLNode, x, flowEnv),
+            "ratiotGml2" = addRatiotGml2(gatingMLNode, x, flowEnv),
+            "ratio" = addRatioGml1.5(gatingMLNode, x, flowEnv),
+            "asinht" = addAsinhtGml1.5(gatingMLNode, x, flowEnv),
+            "compensatedParameter" = NA,
+            "unitytransform" = NA,
+            "numeric" = NA,
+            {
+              errMessage <- paste("Class \'", class(object), "\' is not supported in Gating-ML 2.0 output.", sep="")
+              if(is(object, "singleParameterTransform"))
+                errMessage <- paste(errMessage, " Only Gating-ML 2.0 compatible transformations are supported by Gating-ML 2.0 output. Transformation \'", 
+                                    object@transformationId, "\' is not among those and cannot be included. Therefore, any gate referencing this transformation would be referencing a non-existent transformation in the Gating-ML output. Please correct the gates and transformations in your environment and try again.", sep="")
+              if(is(object, "filter"))
+                errMessage <- paste(errMessage, " Only Gating-ML 2.0 compatible gates are supported by Gating-ML 2.0 output. Filter \'", 
+                                    object@filterId, "\' is not among those and cannot be included. Please remove this filter and any references to it from the environment and try again.", sep="")
+              stop(errMessage, call. = FALSE)    
+            }
+     )
+   }
+   
+   # Add rectangle gate x to the Gating-ML node
+   addRectangleGateNode <- function(gatingMLNode, x, flowEnv, addParent, forceGateId)
+   {
+     gate = objectNameToObject(x, flowEnv)
+     if(!is(gate, "rectangleGate")) stop(paste("Unexpected object insted of a rectangleGate - ", class(gate))) 
+     addDebugMessage(paste("Working on rectangleGate ", gate@filterId, sep=""), flowEnv)
+     
+     myID = getObjectId(gate, forceGateId, flowEnv)
+     if(isIdWrittenToXMLAlready(myID, flowEnv)) return(FALSE) 
+     attrs = c("gating:id" = myID)
+     if (!is.null(addParent)) attrs = c(attrs, "gating:parent_id" = filterIdtoXMLId(addParent, flowEnv))
+     
+     gatingMLNode$addNode("gating:RectangleGate", attrs = attrs, close = FALSE)
+     addDimensions(gatingMLNode, x, flowEnv)
+     gatingMLNode$closeTag() # </gating:RectangleGate>
+   }
+   
+   # Add polygon gate x to the Gating-ML node
+   addPolygonGateNode <- function(gatingMLNode, x, flowEnv, addParent, forceGateId)
+   {
+     gate = objectNameToObject(x, flowEnv)
+     if(!is(gate, "polygonGate")) stop(paste("Unexpected object insted of a polygonGate - ", class(gate))) 
+     addDebugMessage(paste("Working on polygonGate ", gate@filterId, sep=""), flowEnv)
+     
+     myID = getObjectId(gate, forceGateId, flowEnv)
+     if(isIdWrittenToXMLAlready(myID, flowEnv)) return(FALSE) 
+     attrs = c("gating:id" = myID)
+     if (!is.null(addParent)) attrs = c(attrs, "gating:parent_id" = filterIdtoXMLId(addParent, flowEnv))    
+     
+     gatingMLNode$addNode("gating:PolygonGate", attrs = attrs, close = FALSE)
+     addDimensions(gatingMLNode, x, flowEnv)
+     for (i in 1:length(gate@boundaries[,1]))
+     {
+       gatingMLNode$addNode("gating:vertex", close = FALSE)
+       # attrs = c("data-type:value" = gate@boundaries[i,1])
+       attrs = c("data-type:value" = as.numeric(gate@boundaries[i,1]))
+       gatingMLNode$addNode("gating:coordinate", attrs = attrs)
+       # attrs = c("data-type:value" = gate@boundaries[i,2])
+       attrs = c("data-type:value" = as.numeric(gate@boundaries[i,2]))
+       gatingMLNode$addNode("gating:coordinate", attrs = attrs)
+       gatingMLNode$closeTag() # </gating:vertex>
+     }
+     gatingMLNode$closeTag() # </gating:PolygonGate>
+   }
+   
+   # Add ellipse gate x to the Gating-ML node
+   addEllipsoidGateNode <- function(gatingMLNode, x, flowEnv, addParent, forceGateId)
+   {
+     gate = objectNameToObject(x, flowEnv)
+     if(!is(gate, "ellipsoidGate")) stop(paste("Unexpected object insted of an ellipsoidGate - ", class(gate))) 
+     addDebugMessage(paste("Working on ellipsoidGate ", gate@filterId, sep=""), flowEnv)
+     
+     myID = getObjectId(gate, forceGateId, flowEnv)
+     if(isIdWrittenToXMLAlready(myID, flowEnv)) return(FALSE) 
+     attrs = c("gating:id" = myID)
+     if (!is.null(addParent)) attrs = c(attrs, "gating:parent_id" = filterIdtoXMLId(addParent, flowEnv))    
+     
+     gatingMLNode$addNode("gating:EllipsoidGate", attrs = attrs, close = FALSE)
+     addDimensions(gatingMLNode, x, flowEnv)
+     
+     gatingMLNode$addNode("gating:mean", close = FALSE)
+     for (i in 1:length(gate@mean))
+     {
+       attrs = c("data-type:value" = as.numeric(gate@mean[i]))
+       gatingMLNode$addNode("gating:coordinate", attrs = attrs)
+     }
+     gatingMLNode$closeTag() # </gating:mean>
+     
+     gatingMLNode$addNode("gating:covarianceMatrix", close = FALSE)
+     for (row in 1:length(gate@cov[,1]))
+     {
+       gatingMLNode$addNode("gating:row", close = FALSE)
+       for (column in 1:length(gate@cov[1,]))
+       {
+         attrs = c("data-type:value" = gate@cov[row,column])
+         gatingMLNode$addNode("gating:entry", attrs = attrs)
+       }
+       gatingMLNode$closeTag() # </gating:row>
+     }
+     gatingMLNode$closeTag() # </gating:covarianceMatrix>
+     
+     attrs = c("data-type:value" = gate@distance ^ 2)
+     gatingMLNode$addNode("gating:distanceSquare", attrs = attrs)
+     
+     gatingMLNode$closeTag() # </gating:EllipsoidGate>
+   }
+   
+   # Add a Boolean AND gate x to the Gating-ML node
+   addBooleanAndGateNode <- function(gatingMLNode, x, flowEnv, addParent, forceGateId)
+   {
+     gate = objectNameToObject(x, flowEnv)
+     if(!is(gate, "intersectFilter")) stop(paste("Unexpected object insted of an intersectFilter - ", class(gate))) 
+     addDebugMessage(paste("Working on intersectFilter ", gate@filterId, sep=""), flowEnv)
+     
+     myID = getObjectId(gate, forceGateId, flowEnv)
+     if(isIdWrittenToXMLAlready(myID, flowEnv)) return(FALSE) 
+     attrs = c("gating:id" = myID)
+     if (!is.null(addParent)) attrs = c(attrs, "gating:parent_id" = filterIdtoXMLId(addParent, flowEnv))    
+     
+     gatingMLNode$addNode("gating:BooleanGate", attrs = attrs, close = FALSE)
+     gatingMLNode$addNode("gating:and", close = FALSE)
+     if(length(gate@filters) == 0) 
+       stop("Boolean AND gates (intersectFilter) have to reference some arguments.", call. = FALSE)
+     for (i in 1:length(gate@filters))
+     {
+       attrs = c("gating:ref" = filterIdtoXMLId(gate@filters[[i]]@filterId, flowEnv))
+       gatingMLNode$addNode("gating:gateReference", attrs = attrs)
+     }
+     if(length(gate@filters)  == 1) 
+     {
+       # If there was just one referenced filter than we add it twice
+       # since and/or gates require at least two arguments in Gating-ML 2.0
+       gatingMLNode$addNode("gating:gateReference", attrs = attrs)
+     } 
+     gatingMLNode$closeTag() # </gating:and>
+     gatingMLNode$closeTag() # </gating:BooleanGate>    
+   }
+   
+   # Add a Boolean OR gate x to the Gating-ML node
+   addBooleanOrGateNode <- function(gatingMLNode, x, flowEnv, addParent, forceGateId)
+   {
+     gate = objectNameToObject(x, flowEnv)
+     if(!is(gate, "unionFilter")) stop(paste("Unexpected object insted of a unionFilter - ", class(gate))) 
+     addDebugMessage(paste("Working on unionFilter ", gate@filterId, sep=""), flowEnv)
+     
+     myID = getObjectId(gate, forceGateId, flowEnv)
+     if(isIdWrittenToXMLAlready(myID, flowEnv)) return(FALSE) 
+     attrs = c("gating:id" = myID)
+     if (!is.null(addParent)) attrs = c(attrs, "gating:parent_id" = filterIdtoXMLId(addParent, flowEnv))    
+     
+     gatingMLNode$addNode("gating:BooleanGate", attrs = attrs, close = FALSE)
+     gatingMLNode$addNode("gating:or", close = FALSE)
+     if(length(gate@filters) == 0) 
+       stop("Boolean OR gates (unionFilter) have to reference some arguments.", call. = FALSE)
+     for (i in 1:length(gate@filters))
+     {
+       attrs = c("gating:ref" = filterIdtoXMLId(gate@filters[[i]]@filterId, flowEnv))
+       gatingMLNode$addNode("gating:gateReference", attrs = attrs)
+     }
+     if(length(gate@filters)  == 1) 
+     {
+       # If there was just one referenced filter than we add it twice
+       # since and/or gates require at least two arguments in Gating-ML 2.0
+       gatingMLNode$addNode("gating:gateReference", attrs = attrs)
+     } 
+     gatingMLNode$closeTag() # </gating:or>
+     gatingMLNode$closeTag() # </gating:BooleanGate>    
+   }
+   
+   # Add a Boolean NOT gate x to the Gating-ML node
+   addBooleanNotGateNode <- function(gatingMLNode, x, flowEnv, addParent, forceGateId)
+   {
+     gate = objectNameToObject(x, flowEnv)
+     if(!is(gate, "complementFilter")) stop(paste("Unexpected object insted of a complementFilter - ", class(gate))) 
+     addDebugMessage(paste("Working on complementFilter ", gate@filterId, sep=""), flowEnv)
+     
+     myID = getObjectId(gate, forceGateId, flowEnv)
+     if(isIdWrittenToXMLAlready(myID, flowEnv)) return(FALSE) 
+     attrs = c("gating:id" = myID)
+     if (!is.null(addParent)) attrs = c(attrs, "gating:parent_id" = filterIdtoXMLId(addParent, flowEnv))    
+     
+     gatingMLNode$addNode("gating:BooleanGate", attrs = attrs, close = FALSE)
+     gatingMLNode$addNode("gating:not", close = FALSE)
+     if(length(gate@filters)  == 1) 
+     {
+       attrs = c("gating:ref" = filterIdtoXMLId(gate@filters[[1]]@filterId, flowEnv))
+       gatingMLNode$addNode("gating:gateReference", attrs = attrs)
+     } else stop("Boolean NOT gates (complementFilter) have to reference exactly one argument.", call. = FALSE)
+     gatingMLNode$closeTag() # </gating:not>
+     gatingMLNode$closeTag() # </gating:BooleanGate>    
+   }
+   
+   # Add a Quadrant gate x to the Gating-ML node
+   addQuadGateNode <- function(gatingMLNode, x, flowEnv, addParent, forceGateId)
+   {
+     gate = objectNameToObject(x, flowEnv)
+     if(!is(gate, "quadGate")) stop(paste("Unexpected object insted of a quadGate - ", class(gate))) 
+     addDebugMessage(paste("Working on quadGate ", gate@filterId, sep=""), flowEnv)
+     
+     myID = getObjectId(gate, forceGateId, flowEnv)
+     if(isIdWrittenToXMLAlready(myID, flowEnv)) return(FALSE) 
+     attrs = c("gating:id" = myID)
+     if (!is.null(addParent)) attrs = c(attrs, "gating:parent_id" = filterIdtoXMLId(addParent, flowEnv))    
+     
+     gatingMLNode$addNode("gating:QuadrantGate", attrs = attrs, close = FALSE)
+     addDimensions(gatingMLNode, x, flowEnv, myID)
+     
+     attrs = c("gating:id" = paste(myID, ".PP", sep = ""))
+     gatingMLNode$addNode("gating:Quadrant", attrs = attrs, close = FALSE)
+     attrs = c("gating:divider_ref" = paste(myID, ".D1", sep = ""))
+     attrs = c(attrs, "gating:location" = as.character(gate@boundary[1] + 1))
+     gatingMLNode$addNode("gating:position", attrs = attrs)
+     attrs = c("gating:divider_ref" = paste(myID, ".D2", sep = ""))
+     attrs = c(attrs, "gating:location" = as.character(gate@boundary[2] + 1))
+     gatingMLNode$addNode("gating:position", attrs = attrs)
+     gatingMLNode$closeTag() # </gating:Quadrant>
+     
+     attrs = c("gating:id" = paste(myID, ".PN", sep = ""))
+     gatingMLNode$addNode("gating:Quadrant", attrs = attrs, close = FALSE)
+     attrs = c("gating:divider_ref" = paste(myID, ".D1", sep = ""))
+     attrs = c(attrs, "gating:location" = as.character(gate@boundary[1] + 1))
+     gatingMLNode$addNode("gating:position", attrs = attrs)
+     attrs = c("gating:divider_ref" = paste(myID, ".D2", sep = ""))
+     attrs = c(attrs, "gating:location" = as.character(gate@boundary[2] - 1))
+     gatingMLNode$addNode("gating:position", attrs = attrs)
+     gatingMLNode$closeTag() # </gating:Quadrant>
+     
+     attrs = c("gating:id" = paste(myID, ".NP", sep = ""))
+     gatingMLNode$addNode("gating:Quadrant", attrs = attrs, close = FALSE)
+     attrs = c("gating:divider_ref" = paste(myID, ".D1", sep = ""))
+     attrs = c(attrs, "gating:location" = as.character(gate@boundary[1] - 1))
+     gatingMLNode$addNode("gating:position", attrs = attrs)
+     attrs = c("gating:divider_ref" = paste(myID, ".D2", sep = ""))
+     attrs = c(attrs, "gating:location" = as.character(gate@boundary[2] + 1))
+     gatingMLNode$addNode("gating:position", attrs = attrs)
+     gatingMLNode$closeTag() # </gating:Quadrant>
+     
+     attrs = c("gating:id" = paste(myID, ".NN", sep = ""))
+     gatingMLNode$addNode("gating:Quadrant", attrs = attrs, close = FALSE)
+     attrs = c("gating:divider_ref" = paste(myID, ".D1", sep = ""))
+     attrs = c(attrs, "gating:location" = as.character(gate@boundary[1] - 1))
+     gatingMLNode$addNode("gating:position", attrs = attrs)
+     attrs = c("gating:divider_ref" = paste(myID, ".D2", sep = ""))
+     attrs = c(attrs, "gating:location" = as.character(gate@boundary[2] - 1))
+     gatingMLNode$addNode("gating:position", attrs = attrs)
+     gatingMLNode$closeTag() # </gating:Quadrant>
+     
+     gatingMLNode$closeTag() # </gating:QuadrantGate>
+   }
+   
+   # Add a subsetFilter gate named x to the the Gating-ML node
+   addGateWithParent <- function(gatingMLNode, x, flowEnv)
+   {
+     addDebugMessage(paste("Working on ", x, sep=""), flowEnv)
+     gate = objectNameToObject(x, flowEnv)
+     if (!is(gate, "subsetFilter")) stop(paste("Expected a subsetFilter to add a gate with a parent id, but found an object of class", class(gate)))
+     if (length(gate@filters) == 2){
+       newX = gate@filters[[1]]
+       parent = gate@filters[[2]]
+       if (is(parent, 'filterReference')) parentName = parent@name
+       else parentName = parent@filterId
+       addObjectToGatingML(gatingMLNode, newX, flowEnv, parentName, gate@filterId)    
+     }
+     else stop(paste("Unexpected length of filters for class", class(gate)))
+   }
+   
+   # Add a compensation named x to the the Gating-ML node
+   addCompensation <- function(gatingMLNode, x, flowEnv)
+   {
+     myComp = objectNameToObject(x, flowEnv)
+     if(!is(myComp, "compensation")) stop(paste("Unexpected object insted of a compensation - ", class(myComp))) 
+     addDebugMessage(paste("Working on compensation ", myComp@compensationId, sep=""), flowEnv)
+     
+     myID = getObjectId(myComp, NULL, flowEnv)
+     if(isIdWrittenToXMLAlready(myID, flowEnv)) return(FALSE) 
+     
+     detectors <- colnames(myComp@spillover)
+     if (is.null(detectors)) 
+     {
+       stop(paste("Cannot export a spillover matrix without column names (", myComp@compensationId, ").", sep=""))
+       return
+     }
+     
+     fluorochromes <- rownames(myComp@spillover)
+     if(is.null(fluorochromes))
+     {
+       if(nrow(myComp@spillover) != ncol(myComp@spillover)) 
+       {
+         stop(paste("Cannot export a non-sqaure spillover (spectrum) matrix without row names (", myComp@compensationId, ").", sep=""))
+         return
+       }
+       else
+       {
+         fluorochromes <- detectors
+       }
+     }
+     
+     attrs = c("transforms:id" = myID)
+     gatingMLNode$addNode("transforms:spectrumMatrix", attrs = attrs, close = FALSE)
+     
+     gatingMLNode$addNode("transforms:fluorochromes", close = FALSE)
+     for (fname in fluorochromes) 
+     {
+       attrs = c("data-type:name" = fname)
+       gatingMLNode$addNode("data-type:fcs-dimension", attrs = attrs)
+     }
+     gatingMLNode$closeTag() # </transforms:fluorochromes>
+     
+     gatingMLNode$addNode("transforms:detectors", close = FALSE)
+     for (dname in detectors) 
+     {
+       attrs = c("data-type:name" = dname)
+       gatingMLNode$addNode("data-type:fcs-dimension", attrs = attrs)
+     }
+     gatingMLNode$closeTag() # </transforms:detectors>
+     
+     for (rowNo in 1:nrow(myComp@spillover))
+     {
+       gatingMLNode$addNode("transforms:spectrum", close = FALSE)
+       for (colNo in 1:ncol(myComp@spillover)) 
+       {
+         # attrs = c("transforms:value" = myComp@spillover[rowNo,colNo])
+         attrs = c("transforms:value" = as.vector(myComp@spillover[rowNo,colNo]))
+         gatingMLNode$addNode("transforms:coefficient", attrs = attrs)
+       }
+       gatingMLNode$closeTag() # </transforms:spectrum>
+     }
+     
+     gatingMLNode$closeTag() # </transforms:spectrumMatrix>
+   }
+   
+   # Add an asinhtGml2 transformation named x to the the Gating-ML node
+   addAsinhtGml2 <- function(gatingMLNode, x, flowEnv)
+   {
+     myTrans = objectNameToObject(x, flowEnv)
+     if(!is(myTrans, "asinhtGml2")) stop(paste("Unexpected object insted of asinhtGml2 - ", class(myTrans))) 
+     addDebugMessage(paste("Working on asinhtGml2 ", myTrans@transformationId, sep=""), flowEnv)
+     
+     myID = getObjectId(myTrans, NULL, flowEnv)
+     if(isIdWrittenToXMLAlready(myID, flowEnv)) return(FALSE) 
+     
+     attrs = c("transforms:id" = myID)
+     if (is.finite(myTrans@boundMin)) attrs = append(attrs, c("transforms:boundMin" = myTrans@boundMin))
+     if (is.finite(myTrans@boundMax)) attrs = append(attrs, c("transforms:boundMax" = myTrans@boundMax))
+     gatingMLNode$addNode("transforms:transformation", attrs = attrs, close = FALSE)
+     attrs = c("transforms:T" = myTrans@T, "transforms:M" = myTrans@M, "transforms:A" = myTrans@A)
+     gatingMLNode$addNode("transforms:fasinh", attrs = attrs)
+     gatingMLNode$closeTag() # </transforms:transformation>    
+   }
+   
+   # Add an asinht transformation named x to the the Gating-ML node.
+   # Encode asinht from Gating-ML 1.5 compatible parameterization using Gating-ML 2.0
+   # compatible parameterization as follows:
+   #
+   # asinht (ASinH from Gating-ML 1.5) is defined as 
+   # f(x) = asinh(a*x)*b
+   # asinhtGml2 (fasinh from Gating-ML 2.0) is defined as:
+   # f(x) = (asinh(x*sinh(M*log(10))/T) + A*log(10)) / ((M+A)*log(10))
+   # Therefore, we will encode asinht as asinhtGml2 by stating
+   # A = 0
+   # M = 1 / (b * log(10))
+   # T = (sinh(1/b)) / a
+   # which will give us exactly the right transformation in the Gating-ML 2.0 
+   # compatible parameterization. Btw. log is natural logarithm, i.e., based e
+   addAsinhtGml1.5 <- function(gatingMLNode, x, flowEnv)
+   {
+     myTrans = objectNameToObject(x, flowEnv)
+     if(!is(myTrans, "asinht")) stop(paste("Unexpected object insted of asinht - ", class(myTrans))) 
+     addDebugMessage(paste("Working on asinht ", myTrans@transformationId, sep=""), flowEnv)
+     
+     myID = getObjectId(myTrans, NULL, flowEnv)
+     if(isIdWrittenToXMLAlready(myID, flowEnv)) return(FALSE) 
+     
+     attrs = c("transforms:id" = myID)
+     gatingMLNode$addNode("transforms:transformation", attrs = attrs, close = FALSE)
+     
+     A = 0
+     M = 1 / (myTrans@b * log(10))
+     T = (sinh(1/myTrans@b)) / myTrans@a
+     attrs = c("transforms:T" = T, "transforms:M" = M, "transforms:A" = A)
+     
+     gatingMLNode$addNode("transforms:fasinh", attrs = attrs)
+     gatingMLNode$closeTag() # </transforms:transformation>    
+   }
+   
+   # Add a hyperlogtGml2 transformation named x to the the Gating-ML node
+   addHyperlogtGml2 <- function(gatingMLNode, x, flowEnv)
+   {
+     myTrans = objectNameToObject(x, flowEnv)
+     if(!is(myTrans, "hyperlogtGml2")) stop(paste("Unexpected object insted of hyperlogtGml2 - ", class(myTrans))) 
+     addDebugMessage(paste("Working on hyperlogtGml2 ", myTrans@transformationId, sep=""), flowEnv)
+     
+     myID = getObjectId(myTrans, NULL, flowEnv)
+     if(isIdWrittenToXMLAlready(myID, flowEnv)) return(FALSE) 
+     
+     attrs = c("transforms:id" = myID)
+     if (is.finite(myTrans@boundMin)) attrs = append(attrs, c("transforms:boundMin" = myTrans@boundMin))
+     if (is.finite(myTrans@boundMax)) attrs = append(attrs, c("transforms:boundMax" = myTrans@boundMax))
+     gatingMLNode$addNode("transforms:transformation", attrs = attrs, close = FALSE)
+     attrs = c("transforms:T" = myTrans@T, "transforms:M" = myTrans@M, "transforms:W" = myTrans@W, "transforms:A" = myTrans@A)
+     gatingMLNode$addNode("transforms:hyperlog", attrs = attrs)
+     gatingMLNode$closeTag() # </transforms:transformation>    
+   }
+   
+   # Add a logicletGml2 transformation named x to the the Gating-ML node
+   addLogicletGml2 <- function(gatingMLNode, x, flowEnv)
+   {
+     myTrans = objectNameToObject(x, flowEnv)
+     if(!is(myTrans, "logicletGml2")) stop(paste("Unexpected object insted of logicletGml2 - ", class(myTrans))) 
+     addDebugMessage(paste("Working on logicletGml2 ", myTrans@transformationId, sep=""), flowEnv)
+     
+     myID = getObjectId(myTrans, NULL, flowEnv)
+     if(isIdWrittenToXMLAlready(myID, flowEnv)) return(FALSE) 
+     
+     attrs = c("transforms:id" = myID)
+     if (is.finite(myTrans@boundMin)) attrs = append(attrs, c("transforms:boundMin" = myTrans@boundMin))
+     if (is.finite(myTrans@boundMax)) attrs = append(attrs, c("transforms:boundMax" = myTrans@boundMax))
+     gatingMLNode$addNode("transforms:transformation", attrs = attrs, close = FALSE)
+     attrs = c("transforms:T" = myTrans@T, "transforms:M" = myTrans@M, "transforms:W" = myTrans@W, "transforms:A" = myTrans@A)
+     gatingMLNode$addNode("transforms:logicle", attrs = attrs)
+     gatingMLNode$closeTag() # </transforms:transformation>    
+   }
+   
+   # Add a lintGml2 transformation named x to the the Gating-ML node
+   addLintGml2 <- function(gatingMLNode, x, flowEnv)
+   {
+     myTrans = objectNameToObject(x, flowEnv)
+     if(!is(myTrans, "lintGml2")) stop(paste("Unexpected object insted of lintGml2 - ", class(myTrans))) 
+     addDebugMessage(paste("Working on lintGml2 ", myTrans@transformationId, sep=""), flowEnv)
+     
+     myID = getObjectId(myTrans, NULL, flowEnv)
+     if(isIdWrittenToXMLAlready(myID, flowEnv)) return(FALSE) 
+     
+     attrs = c("transforms:id" = myID)
+     if (is.finite(myTrans@boundMin)) attrs = append(attrs, c("transforms:boundMin" = myTrans@boundMin))
+     if (is.finite(myTrans@boundMax)) attrs = append(attrs, c("transforms:boundMax" = myTrans@boundMax))
+     gatingMLNode$addNode("transforms:transformation", attrs = attrs, close = FALSE)
+     attrs = c("transforms:T" = myTrans@T, "transforms:A" = myTrans@A)
+     gatingMLNode$addNode("transforms:flin", attrs = attrs)
+     gatingMLNode$closeTag() # </transforms:transformation>    
+   }
+   
+   # Add a logtGml2 transformation named x to the the Gating-ML node
+   addLogtGml2 <- function(gatingMLNode, x, flowEnv)
+   {
+     myTrans = objectNameToObject(x, flowEnv)
+     if(!is(myTrans, "logtGml2")) stop(paste("Unexpected object insted of logtGml2 - ", class(myTrans))) 
+     addDebugMessage(paste("Working on logtGml2 ", myTrans@transformationId, sep=""), flowEnv)
+     
+     myID = getObjectId(myTrans, NULL, flowEnv)
+     if(isIdWrittenToXMLAlready(myID, flowEnv)) return(FALSE) 
+     
+     attrs = c("transforms:id" = myID)
+     if (is.finite(myTrans@boundMin)) attrs = append(attrs, c("transforms:boundMin" = myTrans@boundMin))
+     if (is.finite(myTrans@boundMax)) attrs = append(attrs, c("transforms:boundMax" = myTrans@boundMax))
+     gatingMLNode$addNode("transforms:transformation", attrs = attrs, close = FALSE)
+     attrs = c("transforms:T" = myTrans@T, "transforms:M" = myTrans@M)
+     gatingMLNode$addNode("transforms:flog", attrs = attrs)
+     gatingMLNode$closeTag() # </transforms:transformation>    
+   }
+   
+   # Add a ratiotGml2 transformation named x to the the Gating-ML node
+   addRatiotGml2 <- function(gatingMLNode, x, flowEnv)
+   {
+     myTrans = objectNameToObject(x, flowEnv)
+     if(!is(myTrans, "ratiotGml2")) stop(paste("Unexpected object insted of ratiotGml2 - ", class(myTrans))) 
+     addDebugMessage(paste("Working on ratiotGml2 ", myTrans@transformationId, sep=""), flowEnv)
+     
+     myID = getObjectId(myTrans, NULL, flowEnv)
+     if(isIdWrittenToXMLAlready(myID, flowEnv)) return(FALSE) 
+     
+     attrs = c("transforms:id" = myID)
+     if (is.finite(myTrans@boundMin)) attrs = append(attrs, c("transforms:boundMin" = myTrans@boundMin))
+     if (is.finite(myTrans@boundMax)) attrs = append(attrs, c("transforms:boundMax" = myTrans@boundMax))
+     gatingMLNode$addNode("transforms:transformation", attrs = attrs, close = FALSE)
+     attrs = c("transforms:A" = myTrans@pA, "transforms:B" = myTrans@pB, "transforms:C" = myTrans@pC)
+     gatingMLNode$addNode("transforms:fratio", attrs = attrs, close = FALSE)
+     addDimensionContents(gatingMLNode, myTrans@numerator, flowEnv)
+     addDimensionContents(gatingMLNode, myTrans@denominator, flowEnv)
+     gatingMLNode$closeTag() # </transforms:fratio>
+     gatingMLNode$closeTag() # </transforms:transformation>    
+   }
+   
+   # Add a ratio transformation (from Gating-ML 1.5) named x 
+   # to the the Gating-ML node. This will be translated to how "fratio" of Gating-ML 2.0
+   # (When we set A = 1, B = 0, C = 0 then ratio of Gating-ML 1.5 == fratio of Gating-ML 2.0)
+   addRatioGml1.5 <- function(gatingMLNode, x, flowEnv)
+   {
+     myTrans = objectNameToObject(x, flowEnv)
+     if(!is(myTrans, "ratio")) stop(paste("Unexpected object insted of ratio - ", class(myTrans))) 
+     addDebugMessage(paste("Working on ratio ", myTrans@transformationId, sep=""), flowEnv)
+     
+     myID = getObjectId(myTrans, NULL, flowEnv)
+     if(isIdWrittenToXMLAlready(myID, flowEnv)) return(FALSE) 
+     
+     attrs = c("transforms:id" = myID)
+     gatingMLNode$addNode("transforms:transformation", attrs = attrs, close = FALSE)
+     attrs = c("transforms:A" = "1", "transforms:B" = "0", "transforms:C" = "0")
+     gatingMLNode$addNode("transforms:fratio", attrs = attrs, close = FALSE)
+     addDimensionContents(gatingMLNode, myTrans@numerator, flowEnv)
+     addDimensionContents(gatingMLNode, myTrans@denominator, flowEnv)
+     gatingMLNode$closeTag() # </transforms:fratio>
+     gatingMLNode$closeTag() # </transforms:transformation>    
+   }
+   
+   
+   # Add a Gating-ML dimension to a Gating-ML node
+   addDimensions <- function(gatingMLNode, x, flowEnv, quadGateDividerIdBasedName = NULL)
+   {
+     gate = objectNameToObject(x, flowEnv)
+     for (i in 1:length(gate@parameters))
+     {
+       attrs = c()
+       parameter = gate@parameters[[i]]
+       
+       if (is(gate, "rectangleGate"))
+       {
+         min = gate@min[[i]]
+         max = gate@max[[i]]
+         if(min != -Inf) attrs = c(attrs, "gating:min" = min)
+         if(max != Inf) attrs = c(attrs, "gating:max" = max)
+       }
+       
+       if(is(parameter, "transformReference")) parameter = resolveTransformationReference(parameter)
+       if(is(parameter, "unitytransform")) attrs = c(attrs, "gating:compensation-ref" = "uncompensated")
+       else if(is(parameter, "singleParameterTransform"))
+       {
+         attrs = c(attrs, "gating:transformation-ref" = filterIdtoXMLId(parameter@transformationId, flowEnv))
+         parameter = parameter@parameters
+         if(is(parameter, "transformReference")) parameter = resolveTransformationReference(parameter)
+         
+         if(is(parameter, "unitytransform")) attrs = c(attrs, "gating:compensation-ref" = "uncompensated")
+         else if(is(parameter, "compensatedParameter")) attrs = addCompensationRef(attrs, parameter, flowEnv)
+         else if(is(parameter, "ratiotGml2") || is(parameter, "ratio")) attrs = addCompensationRef(attrs, parameter@numerator, flowEnv)
+         else stop(paste("Unexpected parameter class ", class(parameter), ", compound transformations are not supported in Gating-ML 2.0.", sep=""))
+       } 
+       else if(is(parameter, "compensatedParameter")) attrs = addCompensationRef(attrs, parameter, flowEnv)
+       else if(is(parameter, "ratiotGml2") || is(parameter, "ratio")) attrs = addCompensationRef(attrs, parameter@numerator, flowEnv)
+       else stop(paste("Unexpected parameter class", class(parameter), "- not supported in Gating-ML 2.0 output)."))
+       
+       if(is(gate, "quadGate")) 
+       {
+         attrs = c(attrs, "gating:id" = paste(quadGateDividerIdBasedName, ".D", i, sep = ""))
+         gatingMLNode$addNode("gating:divider", attrs = attrs, close = FALSE)
+       }
+       else gatingMLNode$addNode("gating:dimension", attrs = attrs, close = FALSE)
+       
+       addDimensionContents(gatingMLNode, parameter, flowEnv)
+       if (is(gate, "quadGate")) gatingMLNode$addNode("gating:value", as.character(gate@boundary[i]))
+       gatingMLNode$closeTag() # </gating:dimension> or </gating:divider>
+     }
+   }
+   
+   # Add the contents of a Gating-ML dimension to a Gating-ML node
+   addDimensionContents <- function(gatingMLNode, parameter, flowEnv)
+   {
+     newDimension = FALSE
+     if(is(parameter, "compensatedParameter")) 
+     {
+       if (parameter@spillRefId == "SpillFromFCS") 
+         attrs = c("data-type:name" = parameter@parameters)
+       else 
+         attrs = c("data-type:name" = parameter@transformationId)
+     }
+     else if(is(parameter, "unitytransform")) attrs = c("data-type:name" = parameter@parameters)
+     else if(is(parameter, "character")) attrs = c("data-type:name" = parameter)
+     else if(is(parameter, "ratiotGml2") || is(parameter, "ratio")) {
+       attrs = c("data-type:transformation-ref" = parameter@transformationId)
+       newDimension = TRUE
+     }
+     else stop(paste("Unrecognized parameter type, class ", class(parameter), ". Note that compound transformations are not supported in Gating-ML 2.0.", sep=""))
+     
+     if(newDimension)
+       gatingMLNode$addNode("data-type:new-dimension", attrs = attrs)
+     else
+       gatingMLNode$addNode("data-type:fcs-dimension", attrs = attrs)
+   }
+   
+   # This converts the identifier to an XML safe identifier and also,
+   # if it is a singleParameterTransform and we have a different 
+   # 'representative' transform for those (saved in flowEnv[['.singleParTransforms']])
+   # then the identifier of the representative is used instead.
+   filterIdtoXMLId <- function(x, flowEnv)
+   {
+     if(!(is.character(x))) stop(paste("Object of class", class(x), "cannot be converted to an XML identifier."))
+     if(length(x) <= 0) stop(paste("An empty string cannot be converted to an XML identifier."))
+     
+     # First, if it is a singleParameterTransform then check for a representative and use it instead eventually
+     trEnv = flowEnv[['.singleParTransforms']]
+     trans = flowEnv[[x]]
+     if(!is.null(trEnv) && !is.null(trans) && is(trans, "singleParameterTransform"))
+     {
+       key = createTransformIdentifier(trans)
+       if (!is.null(trEnv[[key]])) x = trEnv[[key]]        
+     }
+     
+     # Now make it a safe XML identifier
+     # 1) Put an underscore prefix if it starts with a number 
+     if(substr(x, 1, 1) >= "0" && substr(x, 1, 1) <= "9") x = paste("_", x, sep="")
+     # 2) Replace 'strange characters with '.'
+     for(i in 1:nchar(x)) {
+       if(!isNCNameChar(substr(x, i, i))) x <- paste(substr(x, 0, i - 1), '.', substr(x, i + 1, nchar(x)), sep= "")
+     }
+     x
+   }
+   
+   # Return true if you are sure that the character is safe to be placed in
+   # an XML identifier.
+   isNCNameChar <- function(char) { #from: https://rdrr.io/bioc/flowUtils/src/R/writeGatingML.R
+     # Based on the ASCII table and XML NCName syntax
+     asciiValue = as.numeric(charToRaw(char))
+     ##### PLEASE READ NOTE IN THE NEXT LINE
+     if(asciiValue < 32) return(FALSE) ##### ORIGINAL VALUE IN SOURCE WAS 45 #####
+     ##### PLEASE READ NOTE IN THE PREVIOUS LINE
+     if(asciiValue == 47) return(FALSE)
+     ##### PLEASE READ NOTE IN THE NEXT LINES
+     #  if(asciiValue >= 58 && asciiValue <= 64) return(FALSE) ##### ORIGINAL NOT COMMENTED OUT #####
+     #  if(asciiValue >= 91 && asciiValue <= 94) return(FALSE) ##### ORIGINAL NOT COMMENTED OUT #####
+     #  if(asciiValue == 96) return(FALSE) ##### ORIGINAL NOT COMMENTED OUT #####
+     #  if(asciiValue >= 123) return(FALSE) ##### ORIGINAL NOT COMMENTED OUT #####
+     if(asciiValue == 127) return(FALSE) ##### THIS ONE DID NOT EXIST IN ORIGINAL SINCE COVERED IN PREVIOUS LINE
+     TRUE    
+   }
+   
+   # Returns TRUE if and only if x is a singleParameterTransform
+   # and there is another equivalent singleParameterTransform
+   # in flowEnv that is the chosen representative among all
+   # equivalent transforms. This is used to merge transforms
+   # for Gating-ML 2.0 output since in Gating-ML 2.0, the same
+   # transformation is applicable to many FCS parameters. For us,
+   # the transformation with the shortest identifier is the chosen
+   # representative. This function requires the flowEnv[['.singleParTransforms']]
+   # to be set by calling the collectTransform function on all available
+   # transforms before shouldTransformationBeSkipped can be used.
+   shouldTransformationBeSkipped <- function(x, flowEnv)
+   {
+     trEnv = flowEnv[['.singleParTransforms']]
+     trans = flowEnv[[x]]
+     if(!is.null(trEnv) && !is.null(trans) && is(trans, "singleParameterTransform"))
+     {
+       key = createTransformIdentifier(trans)
+       if (!is.null(trEnv[[key]])){
+         if (x == trEnv[[key]]) FALSE
+         else TRUE
+       } else FALSE
+     } else FALSE
+   }
+   
+   # Resolve transformation reference, return the transformation that the
+   # reference is pointing to.
+   resolveTransformationReference <- function(trRef)
+   {
+     if(!is(trRef, "transformReference")) 
+       stop(paste("Cannot call resolveTransformationReference on", class(trRef)))
+     if(exists(trRef@transformationId, envir=trRef@searchEnv, inherits=FALSE))
+       trRef@searchEnv[[trRef@transformationId]]
+     else
+       stop(paste("Cannot find", trRef@transformationId, "in the environment."))
+   }
+   
+   # This will create an identifier of a singleParameterTransform that
+   # is based on the class and slot values, such as T, M, W, A, etc. as applicable
+   # for the various single parameter transformations. We will use this to 
+   # merge "the same transformations" applied to different FCS parameter into a single
+   # transformation in the Gating-ML 2.0 output.
+   createTransformIdentifier <- function(trans)
+   {
+     name <- class(trans)
+     for (slotName in slotNames(trans))
+     {
+       if(slotName != ".Data" && slotName != "parameters" && slotName != "transformationId")
+       {
+         slotValue = slot(trans, slotName)
+         if(is(slotValue, "numeric") || is(slotValue, "character"))
+         {
+           name <- paste(name, slotName, slot(trans, slotName), sep = "_")
+         }
+       }
+     }
+     name
+   }
+   
+   # The flowEnv[['.singleParTransforms']] environment will serve as a hashmap
+   # with keys based on values returned by createTransformIdentifier and
+   # values being the shortest transformationId value of all the transformations
+   # matching that key. That way, we can merge all these transformations into
+   # a single one in Gating-ML.
+   collectTransform <- function(x, flowEnv)
+   {
+     trEnv = flowEnv[['.singleParTransforms']]
+     trans = flowEnv[[x]]
+     key = createTransformIdentifier(trans)
+     if (is.null(trEnv[[key]]) || length(trEnv[[key]]) > trans@transformationId) trEnv[[key]] = trans@transformationId   
+   }
+   
+   # Add a debug message to out list of debug messages in flowEnv[['.debugMessages']]
+   addDebugMessage <- function(msg, flowEnv)
+   {
+     flowEnv[['.debugMessages']] = c(flowEnv[['.debugMessages']], msg)
+   }
+   
+   # Return TRUE of the provided id has been checked (and supposedly written)
+   # before. Otherwise, add the id to the list in flowEnv[['.objectIDsWrittenToXMLOutput']]
+   # and retusn FALSE. This function is used to prevent writing multiple objects
+   # with the same ID to the Gating-ML output in case a gate or transformation
+   # with the same ID is stored several times in the flowEnv.
+   isIdWrittenToXMLAlready <- function(id, flowEnv)
+   {
+     idsList = flowEnv[['.objectIDsWrittenToXMLOutput']]
+     if (is.null(idsList[[id]])) {
+       idsList[[id]] = TRUE
+       flowEnv[['.objectIDsWrittenToXMLOutput']] = idsList 
+       FALSE
+     } else {
+       addDebugMessage(paste("ID", id, "should be in the Gating-ML file already."), flowEnv)
+       TRUE
+     }
+   }
+   
+   # Add an appropriate gating:compensation-ref attribute to the passed attrs
+   addCompensationRef <- function(attrs, parameter, flowEnv)
+   {
+     if(is(parameter, "unitytransform")) attrs = c(attrs, "gating:compensation-ref" = "uncompensated")
+     else if(is(parameter, "compensatedParameter")) 
+     {
+       if (parameter@spillRefId != "SpillFromFCS")
+         attrs = c(attrs, "gating:compensation-ref" = filterIdtoXMLId(parameter@spillRefId, flowEnv))
+       else 
+         attrs = c(attrs, "gating:compensation-ref" = "FCS")
+     }
+     else stop(paste("Unexpected parameter class", class(parameter)))
+     
+     attrs
+   }
+   
+   # Add to attrs the gating:min and/or gating:max attributes 
+   # based on dimension number i of a rectangle gate gate.
+   addRectGateMinMax <- function(attrs, gate, i)
+   {
+     if (is(gate, "rectangleGate"))
+     {
+       min = gate@min[[i]]
+       max = gate@max[[i]]
+       if(min != -Inf) attrs = c(attrs, "gating:min" = min)
+       if(max != Inf) attrs = c(attrs, "gating:max" = max)
+     } else stop(paste("Unexpected gate class", class(gate), "- expected a rectangleGate."))
+     
+     attrs
+   }
+   
+   # Get the XML compliant identifier of an object. This only works for object of type
+   # "filter", "transform" or "compensation". The filterIdtoXMLId function is incorporated,
+   # which includes the use of representative singleParameterTransforms instead of a different
+   # transform whenever it is applied to a different FCS parameter.
+   getObjectId <- function(object, forceGateId, flowEnv)
+   {
+     if (is(object, "filter")) {
+       if (is.null(forceGateId)) myID = filterIdtoXMLId(object@filterId, flowEnv)
+       else myID = filterIdtoXMLId(forceGateId, flowEnv)    
+     } else if (is(object, "transform")) {
+       if (is.null(forceGateId)) myID = filterIdtoXMLId(object@transformationId, flowEnv)
+       else myID = filterIdtoXMLId(forceGateId, flowEnv)
+     } else if (is(object, "compensation")) {
+       if (is.null(forceGateId)) myID = filterIdtoXMLId(object@compensationId, flowEnv)
+       else myID = filterIdtoXMLId(forceGateId, flowEnv)
+     }
+     
+     else stop(paste("Unexpected object to get id from, class", class(object)))
+     myID
+   }
+   
+   # If x is character then return flowEnv[[x]], otherwise return x
+   objectNameToObject <- function(x, flowEnv) 
+   {
+     if(is(x, "character")) flowEnv[[x]]
+     else x
+   }
+   
+   # Check object named x in flowEnv and make sure
+   # flowEnv contains objects referenced from x, such as parameter
+   # transformations used in x. If objects are missing then
+   # add them to flowEnv and keep track of what has been
+   # added in the flowEnv[['.addedObjects']] list so that it can be
+   # removed at the end of the write.gatingML function. 
+   addReferencedObjectsToEnv <- function(x, flowEnv) 
+   {
+     object = objectNameToObject(x, flowEnv)
+     if(is(object, "parameterFilter")) 
+       for(par in object@parameters) doubleCheckExistanceOfParameter(par, flowEnv)
+     else if (is(object, "singleParameterTransform")) 
+       doubleCheckExistanceOfParameter(object@parameters, flowEnv)
+     else if (is(object, "setOperationFilter"))
+       for(filt in object@filters) doubleCheckExistanceOfFilter(filt, flowEnv)
+     
+   }
+   
+   # If par is a transform then check whether it exists in the flowEnv environment, 
+   # and if it doesn't then add it there and make a note of it in flowEnv[['.addedObjects']]
+   doubleCheckExistanceOfParameter <- function(par, flowEnv)
+   {
+     if(is(par, "transform")) 
+     {
+       if(!is.null(par@transformationId) && par@transformationId != "" && !exists(par@transformationId, envir=flowEnv, inherits=FALSE)) 
+       {
+         flowEnv[[par@transformationId]] <- par
+         flowEnv[['.addedObjects']][[par@transformationId]] <- par@transformationId
+         addReferencedObjectsToEnv(par@transformationId, flowEnv)
+       }    
+     }
+   }
+   
+   # If filt is a concreteFilter then check whether it exists in the flowEnv environment, 
+   # and if it doesn't then add it there and make a note of it in flowEnv[['.addedObjects']]
+   doubleCheckExistanceOfFilter <- function(filt, flowEnv)
+   {
+     if(is(filt, "concreteFilter")) 
+     {
+       if(!is.null(filt@filterId) && filt@filterId != "" && !exists(filt@filterId, envir=flowEnv, inherits=FALSE)) 
+       {
+         flowEnv[[filt@filterId]] <- filt
+         flowEnv[['.addedObjects']][[filt@filterId]] <- filt@filterId
+         addReferencedObjectsToEnv(filt@filterId, flowEnv)
+       }    
+     }
+   }
+   
+   #write DAFi gates
+   modified.write.gatingML(flowEnv, outputFile)
+   #write derived parameters
+   write.csv(DAFi_labels, 
+             file = fj_csv_ouput_file, 
+             row.names = FALSE, 
+             quote = TRUE)
+   write.csv(nonDAFi_labels, 
+             file = sub(pattern = ".csv.DAFi.csv$",
+                        replacement = ".csv.nonDAFi.csv",
+                        x = fj_csv_ouput_file,
+                        fixed = FALSE), 
+             row.names = FALSE, 
+             quote = TRUE)
+ }
              CD8+ CD4-_ezDAFi_CD127+  CD8+ CD4-_ezDAFi_CD197. CD127 subset 
                           0.83097371                            0.07469927 
CD8+ CD4-_ezDAFi_Q1: CD45-RA- . CD27+ CD8+ CD4-_ezDAFi_Q2: CD45-RA+ . CD27+ 
                           0.40908866                            0.05326469 
CD8+ CD4-_ezDAFi_Q3: CD45-RA+ . CD27- CD8+ CD4-_ezDAFi_Q4: CD45-RA- . CD27- 
                           0.29362408                            0.21682095 
              CD8+ CD4-_ezDAFi_CD127+  CD8+ CD4-_ezDAFi_CD197. CD127 subset 
                          0.150810091                           0.013542349 
CD8+ CD4-_ezDAFi_Q1: CD45-RA- . CD27+ CD8+ CD4-_ezDAFi_Q2: CD45-RA+ . CD27+ 
                          0.074064175                           0.009622195 
CD8+ CD4-_ezDAFi_Q3: CD45-RA+ . CD27- CD8+ CD4-_ezDAFi_Q4: CD45-RA- . CD27- 
                          0.053603646                           0.039468819 
> 
> # R seems to be saving the .RData when exiting, so let's clean up to at least make that tiny (i.e., empty environment)
> rm(list=ls())
> 
> proc.time()
   user  system elapsed 
 16.025   1.921  19.158 
