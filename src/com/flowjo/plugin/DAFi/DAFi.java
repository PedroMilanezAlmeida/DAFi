//////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2020 Pedro Milanez-Almeida, Ph.D., NIAID/NIH
//
// License
// The software is distributed under the terms of the
// Artistic License 2.0
// http://www.r-project.org/Licenses/Artistic-2.0
//
// Disclaimer
// This software and documentation come with no warranties of any kind.
// This software is provided "as is" and any express or implied
// warranties, including, but not limited to, the implied warranties of
// merchantability and fitness for a particular purpose are disclaimed.
// In no event shall the  copyright holder be liable for any direct,
// indirect, incidental, special, exemplary, or consequential damages
// (including but not limited to, procurement of substitute goods or
// services; loss of use, data or profits; or business interruption)
// however caused and on any theory of liability, whether in contract,
// strict liability, or tort arising in any way out of the use of this
// software.
//////////////////////////////////////////////////////////////////////////////
// Based on the FlowSOM plugin
//////////////////////////////////////////////////////////////////////////////


package com.flowjo.plugin.DAFi;

import com.flowjo.plugin.DAFi.DAFiRFlowCalc;
import com.treestar.flowjo.application.workspace.Workspace;
import com.treestar.flowjo.application.workspace.manager.FJApplication;
import com.treestar.flowjo.application.workspace.manager.WSDocument;
import com.treestar.flowjo.core.Sample;
import com.treestar.flowjo.core.nodes.PopNode;
import com.treestar.flowjo.engine.FEML;
import com.treestar.flowjo.engine.utility.R_Algorithm;
import com.treestar.lib.FJPluginHelper;
import com.treestar.lib.PluginHelper;
import com.treestar.lib.core.ExportFileTypes;
import com.treestar.lib.core.ExternalAlgorithmResults;
import com.treestar.lib.data.StringUtil;
import com.treestar.lib.file.FJFileRef;
import com.treestar.lib.file.FJFileRefFactory;
import com.treestar.lib.fjml.FJML;
import com.treestar.lib.fjml.types.FileTypes;
import com.treestar.lib.gui.FJList;
import com.treestar.lib.gui.GuiFactory;
import com.treestar.lib.gui.HBox;
import com.treestar.lib.gui.numberfields.RangedIntegerTextField;
import com.treestar.lib.gui.panels.FJLabel;
import com.treestar.lib.gui.swing.FJCheckBox;
import com.treestar.lib.gui.swing.FJComboBox;
import com.treestar.lib.parsing.interpreter.CSVReader;
import com.treestar.lib.parsing.interpreter.ParseUtil;
import com.treestar.lib.xml.SElement;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.io.*;
import java.net.URL;
import java.util.*;
import java.util.List;

public class DAFi extends R_Algorithm {

    private static final String pluginVersion = "0.1";
    public static String pluginName = "DAFi";
    public static boolean runAgain = false;
    public static boolean nameSet = false;
    public static String runID = "";

    public static final String One = "1";
    public static final String Zero = "0";
    public static final String True = "true";
    public static final String False = "false";
    public static final String cellIdParName = "CellId";


    private RangedIntegerTextField fDimXField = null, fDimYField = null;
    private RangedIntegerTextField fMinPopSizeField = null;
    private FJComboBox fApplyOnPrevCombo = null;
    private FJCheckBox fScaleOptionCheckbox = null;
    private FJCheckBox fApplyOnChildrenCheckbox = null;

    private static final int fixedLabelWidth = 130;
    private static final int fixedFieldWidth = 75;
    private static final int fixedLabelHeigth = 25;
    private static final int fixedFieldHeigth = 25;
    private static final int fixedToolTipWidth = 300;
    private static final int fixedComboWidth = 250;
    private static final int hSpaceHeigth = 5;
    private SElement fsElement = null;
    private static final String space = " ";

    private static final String applyOnPrevLabel = "Apply on map";
    private static final String applyOnPrevTooltip = "If you have executed DAFi before, you can apply new data to a map generated by previous runs of DAFi. A new DAFi object will be created with the same grid but new mapping, node sizes and mean values.";
    private static final String keepResultsTooltip = "Keep a file that shows execution of the script.";
    private static final String keepResultsLabel = "Save the R script and output messages";
    private static final String dimXLabel = "SOM grid size (W x H)";
    private static final String dimXTooltip = "Width of the grid for building the self-organizing map.";
    private static final String dimYTooltip = "Height of the grid for building the self-organizing map.";
    private static final String minPopSizeLabel = "min #events to DAFi";
    private static final String mustBeMinPopSizeLabel = "(min #events must be larger than SOM grid size W x H!)";
    private static final String minPopSizeTooltip = "Smallest number of cells to apply DAFi on.";

    private static final String displayLabel = "Display options";
    private static final String orPerformDAFiLabel = "or perform new DAFi";
    private static final String scaleLabel = "Scale";
    private static final String scaleTooltip = "Should the data be scaled by the FlowSOM function?";
    private static final String applyOnChildrenLabel = "Apply on children only (otherwise on children and children of children)";
    private static final String applyOnChildrenTooltip = "If checked, DAFi will refine only the children of the selected population. If unchecked, all children of children will be refined recursively (i.e., all sub-populations downstream of the selected one).";

    public static final String scaleOptionName = "scale";
    public static final String applyOnChildrenOptionName = "childrenOnly";
    public static final String xDimOptionName = "xdim";
    public static final String yDimOptionName = "ydim";
    public static final String minPopSizeOptionName = "minPopSize";
    public static final String applyOnPrevOptionName = "applyOn"; // "None" or file path to an RData file with a DAFi object
    public static final String pluginFolderAttName = "pluginFolder";

    public static final String RDataFileExtension = ".RData";
    public static final String RDataFileSuffix = ".csv.DAFi.csv.RData";
    public static final String CSVwithParsFileSuffix = ".csv.DAFi.csv.pars.csv";

    public static final int defaultXDim = 10;
    public static final int defaultYDim = 10;
    public static final int defaultMinPopSize = 500;
    public static final String defaultApplyOnPrev = "None";
    public static final boolean defaultScale = true;
    public static final boolean defaultApplyOnChildren = true;

    private boolean fScale = defaultScale;
    private boolean fApplyOnChildren = defaultApplyOnChildren;
    private int fndimx = defaultXDim, fndimy = defaultYDim;
    private int fnMinPopSize = defaultMinPopSize;

    private static final String channelsLabelLine1 = "FCS channels to be used by DAFi. Select multiple items by pressing the Shift";
    private static final String channelsLabelLine2 = "key or toggle items by holding the Ctrl (or Cmd) keys.";
    private static final String channelsLabelLine3 = "You must include FSC and SSC if these are used in any gates (e.g., CD14xSSC)!";

    private static final String citingLabelLine1 = "Required: if using DAFi, cite";
    private static final String citingLabelLine2 = "ADD CITATION LINE 1";
    private static final String citingLabelLine3 = "ADD CITATION LINE 2";
    private static final String citingLabelLine4 = "ADD CITATION LINE 3";

    protected static final String sIconName = "images/DAFiIcon.png";

    private static Icon myIcon = null;
    private static final String Failed = "Failed";

    public DAFi() {
        super(pluginName);
        fShowOutput = true;
    }

    public String getVersion() {
        return (pluginVersion);
    }

    @Override
    public String getName() {
        return pluginName;
    }

    @Override
    public Icon getIcon() {
        if (myIcon == null) {
            URL url = DAFi.class.getResource(getIconName());
            if (url != null)
                myIcon = new ImageIcon(url);
        }
        return myIcon;
    }

    @Override
    protected String getIconName() {
        return sIconName;
    }

    @Override
    protected boolean showClusterInputField() {
        return false;
    }

    @Override
    public ExportFileTypes useExportFileType() {
        return ExportFileTypes.CSV_CHANNEL;
    }

    public ExternalAlgorithmResults invokeAlgorithm(SElement fcmlQueryElement, File sampleFile, File outputFolder) {
        ExternalAlgorithmResults results = new ExternalAlgorithmResults();

        // RunAgain is set to true when the user double clicks on the plugin node, this avoids the recalculation on update.
        if (!runAgain) {
            return results;
        }
        // If the plugin fails, we need to avoid the recalculation as it might not get fixed anyways.
        runAgain = false;

        if (!sampleFile.exists()) {
            // results.setErrorMessage("Input file did not exist"); // We purposely don't want to set the error as there may be undesirable side-effects
            JOptionPane.showMessageDialog(null, "Input file did not exist", "DAFi error", JOptionPane.ERROR_MESSAGE);
            results.setWorkspaceString(DAFi.Failed);
            return results;
        } else {
            // Let's force recalculation all the time because it's relatively quick and we don't seem to handle
            // checkUseExistingFiles well (i.e., if input settings change a bit, we still tend to return previous
            // results instead of recalculating
            // checkUseExistingFiles(fcmlQueryElement);
            fUseExistingFiles = false;
            Sample sample = FJPluginHelper.getSample(fcmlQueryElement);
            Workspace workspace = sample.getWorkspace();
            workspace.getDoc().save();

            String sampleName = StringUtil.rtrim(sampleFile.getName(), ".fcs");

            // Get the parent popnode
            PopNode popNode = FJPluginHelper.getParentPopNode(fcmlQueryElement);

            // This means the current parent node is the root sample, if it is just take the sample node.
            if (popNode == null) {
                popNode = sample.getSampleNode();
            }
            DAFiRFlowCalc calculator = new DAFiRFlowCalc();
            // Added the population node
            File DAFiResult = calculator.runDAFi(sampleFile, sampleName, popNode.getName(), preprocessCompParameterNames(), fOptions, outputFolder.getAbsolutePath(), useExistingFiles());
            calculator.deleteScriptFile();
            checkROutFile(calculator);

            // Added to avoid issue with sub pops in FlowJo.
            if (isSeqGeq()) {
                results.setCSVFile(DAFiResult);
            } else {
                // Workaround for merging a CSV file back in subpops.
                mergeCSVFile(fcmlQueryElement, results, DAFiResult, sampleFile, outputFolder);
            }
            System.out.println(DAFiResult.getAbsolutePath());
            List<Float> values = extractUniqueValuesForParameter(DAFiResult);
            addGatingML(results, values);

            String xmlEnding = sampleFile.getName() + ".gating-ml2.xml";

            FilenameFilter xmlFileFilter = (dir, name) -> name.endsWith(xmlEnding);

            File[] xmlFiles = outputFolder.listFiles(xmlFileFilter);

            for (File xmlFile : xmlFiles)
            {
                String gatingML = readGatingMLFile(xmlFile);
                results.setGatingML(gatingML);
            }

            long timeStamp = System.currentTimeMillis();

            return results;
        }
    }

    private void mergeCSVFile(SElement fcmlQueryElement, ExternalAlgorithmResults results, File umapResults, File sampleFile, File outputFolder) {
        File restFile = null;
        try {
            restFile = generateDerivedParameterCSVFile2(fcmlQueryElement, results, umapResults, sampleFile, getName(), outputFolder.getAbsolutePath(), 0.0);
        } catch (IOException ex) {
        }
        FJFileRef csvFile = null;
        try {
            csvFile = FJFileRefFactory.make(restFile.getAbsolutePath());
        } catch (IOException ex) {
        }

        int numExport = FJPluginHelper.getNumTotalEvents(fcmlQueryElement);
        String sampleName = FJPluginHelper.getSampleName(fcmlQueryElement);

        FJFileRef retFile = null;

        try {
            retFile = generateDerivedParameterCSVFile(csvFile, numExport, sampleName, outputFolder.getAbsolutePath());
        } catch (IOException ex) {
        }
        PluginHelper.createClusterParameter(results, pluginName, retFile.getLocalFile());
    }


    public FJFileRef generateDerivedParameterCSVFile(FJFileRef inputCSVFileRef, int numEvents, String popName, String outputFolder) throws IOException {
        File inputCSVFile = inputCSVFileRef.getLocalFile();
        if (!inputCSVFile.exists()) // return early if input file does not exist
            return null;

        BufferedReader inputCSVFileReader = new BufferedReader(new FileReader(inputCSVFile));
        // read the first header line of the input CSV sample file
        String csvLine = inputCSVFileReader.readLine();
        // determine which column is the event number column
        int eventNumColumnIndex = -1; // the column index of the event number column
        int colCt = 0;
        String headerLine = ""; // the column header to write in the new file
        String noEventLine = ""; // the line to write when there is no derived parameter value
        StringTokenizer tokenizer = new StringTokenizer(csvLine, ",");
        while (tokenizer.hasMoreTokens()) {
            String token = tokenizer.nextToken();
            if (token.contains(FJML.EventNumberDP))
                eventNumColumnIndex = colCt;
            else if (eventNumColumnIndex >= 0) {
                headerLine += token + ",";
                noEventLine += "0,";
            }
            colCt++;
        }
        if (headerLine.endsWith(",")) // get rid of trailing comma of header line
            headerLine = headerLine.substring(0, headerLine.length() - 1);
        headerLine += "\n";
        if (noEventLine.endsWith(",")) // get rid of trailing comma of no parameter value line
            noEventLine = noEventLine.substring(0, noEventLine.length() - 1);
        noEventLine += "\n";

        File outFile = new File(outputFolder, popName + FEML.EPA_Suffix);
        Writer output = new BufferedWriter(new FileWriter(outFile));
        if (true)
            output.write(headerLine);
        int ct = 0;
        int eventNum = 0;
        String separator = colCt == 2 ? "" : ","; // if only 2 columns, one is event number, other is single column, so don't need the trailing comma
        while ((csvLine = inputCSVFileReader.readLine()) != null) {
            tokenizer = new StringTokenizer(csvLine, ",");
            colCt = 0;
            String line = "";
            while (tokenizer.hasMoreTokens()) {
                String token = tokenizer.nextToken();
                if (colCt == eventNumColumnIndex) // get the event number as integer
                    eventNum = (int) ParseUtil.getDouble(token);
                else if (colCt > eventNumColumnIndex) // it's a column after the event number, make it a derived parameter value
                    line += token + separator;
                colCt++;
            }
            if (eventNum < 0)
                break;
            while (ct < eventNum - 1 && ct < numEvents) {
                output.write(noEventLine);
                ct++;
            }
            output.write(line);
            output.write("\n");
            ct++;
        }
        while (ct < numEvents) {
            output.write(noEventLine);
            ct++;
        }
        inputCSVFileReader.close();
        output.close();

        FJFileRef fjFileRef = null;
        try {
            fjFileRef = FJFileRefFactory.make(outFile.getAbsolutePath());
        } catch (IOException e) {
            e.printStackTrace();
        }
        return fjFileRef;
    }

    private String readGatingMLFile(File file){
        CSVReader csvReader = null;
        try {
            csvReader = new CSVReader(new FileReader(file));
            String gatingML = "";
            List<String[]> data = csvReader.readAll();
            for (String[] row : data){
                for (int i = 0; i < row.length; i++) {
                    gatingML+= row[i];
                }
                gatingML+=" ";
            }
            return gatingML;
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return "";
    }

    private static File generateDerivedParameterCSVFile2(SElement fcmlElem, ExternalAlgorithmResults algorithmResults, File pluginCSVFile, File sampleCSVFile, String pluginName, String outputFolder, double noVal) throws IOException {
        if (!pluginCSVFile.exists() || !sampleCSVFile.exists()) // return early if input files do not exist
        {
            return null;
        }
        if (sampleCSVFile.getName().endsWith(FileTypes.FCS_SUFFIX)) {
            algorithmResults.setErrorMessage("The Population Plugin must specify CSV for the useExportType to create cluster parameters.");
            return null;
        }
        SElement externalPopNodeElement = PluginHelper.getExternalPopNodeElement(fcmlElem);
        if (externalPopNodeElement == null) // if no <ExternalPopNode> element, something's wrong
        {
            return null;
        }
        int numEvents = PluginHelper.getNumTotalEvents(fcmlElem);
        BufferedReader sampleCSVFileReader = new BufferedReader(new FileReader(sampleCSVFile));
        // read the first header line of the input sample CSV file
        String sampleCSVLine = sampleCSVFileReader.readLine();
        // determine which column is the event number column
        int eventNumColumnIndex = -1; // the column index of the event number column
        int colCt = 0;
        StringTokenizer tokenizer = new StringTokenizer(sampleCSVLine, ",");
        while (tokenizer.hasMoreTokens()) {
            String token = tokenizer.nextToken();
            if (token.contains(FJML.EventNumberDP)) {
                eventNumColumnIndex = colCt;
            }
            colCt++;
        }
        // now determine number of columns in input plugin csv file
        BufferedReader pluginCSVFileReader = new BufferedReader(new FileReader(pluginCSVFile));
        String pluginCSVLine = pluginCSVFileReader.readLine();
        colCt = 0;
        tokenizer = new StringTokenizer(pluginCSVLine, ",");
        String noEventLine = space + noVal + ","; // the line to write when there is no derived parameter value
        while (tokenizer.hasMoreTokens()) {
            noEventLine += noVal + ",";
            tokenizer.nextToken();
            colCt++;
        }
        if (noEventLine.endsWith(",")) // get rid of trailing comma of no parameter value line
        {
            noEventLine = noEventLine.substring(0, noEventLine.length() - 1);
        }
        noEventLine += "\n";

        // Extract the hierarchical gating path from <ExternalPopNode>
        String pathString = externalPopNodeElement.getString(FJML.path);
        List<String> paths = StringUtil.stringToPath(pathString);
        paths = new ArrayList<String>(paths);
        if (paths.size() > 1) // remove last name in the path, it's the plugin node
        {
            paths.remove(paths.size() - 1);
        }
        pathString = space;
        for (String p : paths) {
            pathString += p + ".";
        }

        String sampleName = FJPluginHelper.getSampleName(fcmlElem);
        if (sampleName.endsWith(FileTypes.FCS_SUFFIX)) {
            sampleName = sampleName.substring(0, sampleName.length() - FileTypes.FCS_SUFFIX.length());
        }
        if (sampleName.endsWith(FileTypes.CSV_SUFFIX) || sampleName.endsWith(FileTypes.TXT_SUFFIX)) {
            sampleName = sampleName.substring(0, sampleName.length() - FileTypes.CSV_SUFFIX.length());
        }
        String outFileName = pathString + sampleName + ".EPA" + FileTypes.CSV_SUFFIX;
        File outFile = new File(outputFolder, outFileName);
        Writer output = new BufferedWriter(new FileWriter(outFile));
        int ct = 0;
        int eventNum = 0;
        output.write(FJML.EventNumberDP + "," + pluginCSVLine + "\n");

        // reading sample and plugin CSV file in parallel
        while ((sampleCSVLine = sampleCSVFileReader.readLine()) != null && (pluginCSVLine = pluginCSVFileReader.readLine()) != null) {
            // get event number to write in first column
            tokenizer = new StringTokenizer(sampleCSVLine, ",");
            colCt = 0;
            String line = space;
            while (tokenizer.hasMoreTokens()) {
                String token = tokenizer.nextToken();
                if (colCt == eventNumColumnIndex) // get the event number as integer
                {
                    eventNum = (int) ParseUtil.getDouble(token);
                    line += eventNum + ",";
                }
                colCt++;
            }
            if (eventNum < 0) {
                break;
            }
            while (ct < eventNum - 1 && ct < numEvents) {
                output.write(noEventLine);
                ct++;
            }
            line += pluginCSVLine;
            output.write(line);
            output.write("\n");
            ct++;
        }
        while (ct < numEvents) {
            output.write(noEventLine);
            ct++;
        }
        pluginCSVFileReader.close();
        sampleCSVFileReader.close();
        output.close();
        return outFile;
    }


    private void addTableFromCSVToResults(ExternalAlgorithmResults results, File csvFile) {
        if (csvFile.exists()) {
            Scanner scan;
            try {
                int nCols = 0;
                scan = new Scanner(csvFile);
                if (scan.hasNextLine()) {
                    String line = scan.nextLine();
                    String[] values = line.split(",");
                    if (values != null) {
                        nCols = values.length;
                        for (int i = 0; i < nCols; i++)
                            values[i] = values[i].replaceAll("^\"|\"$", "").replaceAll("<", "(").replaceAll(">", ")");
                        results.setTableHeaders(values);
                    }
                }
                ArrayList<double[]> listOfLines = new ArrayList<double[]>();
                if (nCols > 0) {
                    while (scan.hasNextLine()) {
                        String line = scan.nextLine();
                        String[] values = line.split(",");
                        if (values != null && values.length == nCols) { // Only process lines with the correct number of columns
                            double dV[] = new double[nCols];
                            for (int i = 0; i < values.length; i++) {
                                dV[i] = Double.parseDouble(values[i].replaceAll("^\"|\"$", ""));
                            }
                            listOfLines.add(dV);
                        }
                    }
                    double[][] v = new double[listOfLines.size()][nCols];
                    for (int i = 0; i < listOfLines.size(); i++) {
                        for (int j = 0; j < nCols; j++) {
                            v[i][j] = listOfLines.get(i)[j];
                        }
                    }
                    results.setValuesTable(v);
                }


            } catch (FileNotFoundException e) {
            }
        }
    }

    @Override
    protected List<Component> getPromptComponents(SElement fcmlElem, SElement algorithmElement, List<String> parameterNames) {
        // We need the plugin output folder and we want to add that to the algorithmElement so that later on, we can scan that folder for any existing .RData files.
        // Unfortunately, FJPluginHelper.getPluginOutputFolder(fcmlElem, this) seems to be returning null sometimes,
        // i.e., this may be called before the plugin output folder is set. Therefore, this is a work around:
        Sample sample = FJPluginHelper.getSample(fcmlElem);
        if (sample != null) {
            Workspace ws = sample.getWorkspace();
            if (ws != null) {
                try {
                    WSDocument wsd = ws.getDoc();
                    String wsDir = wsd.getWorkspaceDirectory().getAbsolutePath();
                    String wsName = wsd.getFilename();
                    String outputFolder = wsDir + File.separator + wsName.substring(0, wsName.lastIndexOf('.')) + File.separator + this.getName();
                    File pluginFolder = new File(outputFolder);
                    if (pluginFolder.exists())
                        algorithmElement.setAttribute(pluginFolderAttName, outputFolder);
                } catch (Exception e) {
                }
                ;
            }
        }
        fsElement = fcmlElem;
        List<Component> ret = super.getPromptComponents(fcmlElem, algorithmElement, parameterNames);

        runAgain = true;
        return ret;
    }


    @SuppressWarnings("unchecked")
    @Override
    protected List<Component> getPromptComponents(SElement selement, List<String> list) {
        ArrayList<Component> componentList = new ArrayList<>();

        FJLabel fjLabel1 = new FJLabel(channelsLabelLine1);
        FJLabel fjLabel2 = new FJLabel(channelsLabelLine2);
        FJLabel fjLabel3 = new FJLabel(channelsLabelLine3);

        componentList.add(fjLabel1);
        componentList.add(fjLabel2);
        componentList.add(fjLabel3);


        componentList.add(addFlowJoParameterSelector(list));
        fsElement = selement;

        int nPars = list.size();
        String plotOptions[] = new String[nPars + 1];
        int i = 1;
        for (String p : list)
            plotOptions[i++] = p;

        fApplyOnPrevCombo = new FJComboBox(new String[]{defaultApplyOnPrev});
        String pluginFolder = selement.getString(pluginFolderAttName);
        if (pluginFolder != null && !pluginFolder.isEmpty()) {
            File myDir = new File(pluginFolder);
            if (myDir.exists()) {
                File[] existingRDataFiles = myDir.listFiles(new FilenameFilter() {
                    public boolean accept(File dir, String name) {
                        return name.endsWith(DAFi.RDataFileExtension);
                    }
                });
                for (File rDataFile : existingRDataFiles) {
                    String rDataName = rDataFile.getName();
                    if (rDataName.contains(DAFi.RDataFileSuffix))
                        rDataName = rDataName.substring(0, rDataName.lastIndexOf(DAFi.RDataFileSuffix));
                    fApplyOnPrevCombo.addItem(rDataName);
                }
            }
        }

        // Default parameter values
        fndimx = defaultXDim;
        fndimy = defaultYDim;
        fScale = defaultScale;
        fApplyOnChildren = defaultApplyOnChildren;
        fnMinPopSize = defaultMinPopSize;

        // If there are option set already (e.g., from the workspace), then
        // let's retrieve those and use them instead of defaults.
        Iterator<SElement> iterator = selement.getChildren("Option").iterator();
        int savedViewOptionIndex = 0;
        int savedPlotOptionIndex = 0;

        while (iterator.hasNext()) {
            SElement option = iterator.next();

            int savedDimx = option.getInt(xDimOptionName, -1);
            if (savedDimx >= 3 && savedDimx <= 30) fndimx = savedDimx;

            int savedDimy = option.getInt(yDimOptionName, -1);
            if (savedDimy >= 3 && savedDimy <= 30) fndimy = savedDimy;

            int nApplyOnPrevComboItemsCount = fApplyOnPrevCombo.getItemCount();
            String savedApplyOnPrevOption = option.getString(applyOnPrevOptionName);
            if (savedApplyOnPrevOption != null && savedApplyOnPrevOption.length() > 5)
                for (int j = 0; j < nApplyOnPrevComboItemsCount; j++) {
                    String itemValue = (String) fApplyOnPrevCombo.getItemAt(j);
                    if (savedApplyOnPrevOption.startsWith(itemValue))
                        fApplyOnPrevCombo.setSelectedIndex(j);
                }

            String savedApplyOnChildren = option.getAttributeValue(applyOnChildrenOptionName);
            if (savedApplyOnChildren != null && !savedApplyOnChildren.isEmpty())
                fApplyOnChildren = One.equals(savedApplyOnChildren) || True.equals(savedApplyOnChildren);

            String savedScale = option.getAttributeValue(scaleOptionName);
            if (savedScale != null && !savedScale.isEmpty())
                fScale = One.equals(savedScale) || True.equals(savedScale);

            int savedMinPopSize = option.getInt(minPopSizeOptionName, -1);
            if (savedMinPopSize >= 100 && savedMinPopSize <= 100000) fnMinPopSize = savedMinPopSize;


        }

        fApplyOnPrevCombo.addItemListener(new ItemListener() {
            @Override
            public void itemStateChanged(ItemEvent e) {
                refreshComponentsEnabled(fApplyOnPrevCombo);
            }
        });
        fApplyOnChildrenCheckbox = new FJCheckBox(applyOnChildrenLabel);
        fApplyOnChildrenCheckbox.setToolTipText("<html><p width=\"" + fixedToolTipWidth + "\">" + applyOnChildrenTooltip + "</p></html>");
        fApplyOnChildrenCheckbox.setSelected(fApplyOnChildren);
        componentList.add(new HBox(new Component[]{fApplyOnChildrenCheckbox}));

        refreshComponentsEnabled(fApplyOnPrevCombo);

        FJLabel LabelApplyOnPrev = new FJLabel(applyOnPrevLabel);
        fApplyOnPrevCombo.setToolTipText("<html><p width=\"" + fixedToolTipWidth + "\">" + applyOnPrevTooltip + "</p></html>");
        GuiFactory.setSizes(fApplyOnPrevCombo, new Dimension(fixedComboWidth, fixedFieldHeigth));
        GuiFactory.setSizes(LabelApplyOnPrev, new Dimension(fixedLabelWidth, fixedLabelHeigth));
        HBox hboxApplyOnPrev = new HBox(new Component[]{LabelApplyOnPrev, fApplyOnPrevCombo});
        componentList.add(hboxApplyOnPrev);
        componentList.add(new HBox(new Component[]{new FJLabel(orPerformDAFiLabel)}));

        FJLabel fjLabelMinPopSize = new FJLabel(minPopSizeLabel);
        fMinPopSizeField = new RangedIntegerTextField(100, 1000000);
        fMinPopSizeField.setInt(fnMinPopSize);
        fMinPopSizeField.setToolTipText("<html><p width=\"" + fixedToolTipWidth + "\">" + minPopSizeTooltip + "</p></html>");
        GuiFactory.setSizes(fMinPopSizeField, new Dimension(fixedFieldWidth, fixedFieldHeigth));
        GuiFactory.setSizes(fjLabelMinPopSize, new Dimension(fixedLabelWidth, fixedLabelHeigth));

        HBox hboxMinPopSize = new HBox(new Component[]{fjLabelMinPopSize, fMinPopSizeField});
        componentList.add(hboxMinPopSize);
        componentList.add(new HBox(new Component[]{new FJLabel(mustBeMinPopSizeLabel)}));

        FJLabel fjLabelDimX = new FJLabel(dimXLabel);
        fDimXField = new RangedIntegerTextField(3, 30);
        fDimXField.setInt(fndimx);
        fDimXField.setToolTipText("<html><p width=\"" + fixedToolTipWidth + "\">" + dimXTooltip + "</p></html>");
        GuiFactory.setSizes(fDimXField, new Dimension(fixedFieldWidth, fixedFieldHeigth));
        GuiFactory.setSizes(fjLabelDimX, new Dimension(fixedLabelWidth, fixedLabelHeigth));

        fDimYField = new RangedIntegerTextField(3, 30);
        fDimYField.setInt(fndimy);
        fDimYField.setToolTipText("<html><p width=\"" + fixedToolTipWidth + "\">" + dimYTooltip + "</p></html>");
        GuiFactory.setSizes(fDimYField, new Dimension(fixedFieldWidth, fixedFieldHeigth));

        HBox hboxDimXY = new HBox(new Component[]{fjLabelDimX, fDimXField, /*fjLabelDimY,*/new FJLabel("x"), fDimYField});
        componentList.add(hboxDimXY);

        fScaleOptionCheckbox = new FJCheckBox(scaleLabel);
        fScaleOptionCheckbox.setToolTipText("<html><p width=\"" + fixedToolTipWidth + "\">" + scaleTooltip + "</p></html>");
        fScaleOptionCheckbox.setSelected(fScale);
        componentList.add(new HBox(new Component[]{fScaleOptionCheckbox}));

        componentList.add(new HBox(new Component[]{new FJLabel(displayLabel)}));

        fShowOutputCheckBox = new JCheckBox(keepResultsLabel);
        fShowOutputCheckBox.setToolTipText("Keep a file that shows execution of the script");
        fShowOutputCheckBox.setToolTipText("<html><p width=\"" + fixedToolTipWidth + "\">" + keepResultsTooltip + "</p></html>");
        fShowOutputCheckBox.setSelected(fShowOutput);
        componentList.add(new HBox(new Component[]{fShowOutputCheckBox}));

        if (!fRoutFile.isEmpty())
            componentList.add(new HBox(Box.createHorizontalGlue(), createShowOutputButton(), Box.createHorizontalGlue()));

        FJLabel hSpaceLabelCiting = new FJLabel("");
        GuiFactory.setSizes(hSpaceLabelCiting, new Dimension(fixedLabelWidth, hSpaceHeigth));
        componentList.add(hSpaceLabelCiting);

        componentList.add(new FJLabel(citingLabelLine1));
        componentList.add(new FJLabel(citingLabelLine2));
        componentList.add(new FJLabel(citingLabelLine3));
        componentList.add(new FJLabel(citingLabelLine4));

        return componentList;
    }

    public JScrollPane addFlowJoParameterSelector(List<String> parameters) {

        if (fParameterNameList == null) {
            DefaultListModel dlm = new DefaultListModel();
            for (int i = 0; i < parameters.size(); i++) {
                dlm.add(i, parameters.get(i));
            }
            fParameterNameList = new FJList(dlm);
            fParameterNameList.setSelectionMode(2);
        }

        JScrollPane scrollableList = new JScrollPane(fParameterNameList);
        int[] indexes = new int[fParameterNameList.getModel().getSize()];
        for (int i = 0; i < indexes.length; i++) {
            indexes[i] = i;
        }
        fParameterNameList.setSelectedIndices(indexes);
        return scrollableList;
    }


    protected void refreshComponentsEnabled(FJComboBox applyOnPrevCombo) {
        if (applyOnPrevCombo != null) {
            if (applyOnPrevCombo.getSelectedIndex() > 0) {
                if (fDimXField != null) fDimXField.setEnabled(false);
                if (fDimYField != null) fDimYField.setEnabled(false);
                if (fScaleOptionCheckbox != null) fScaleOptionCheckbox.setEnabled(false);
                if (fApplyOnChildrenCheckbox != null) fApplyOnChildrenCheckbox.setEnabled(false);

                // If we are selecting the application on existing map then let's select the same parameters
                // in the parameter selector, and let's do so based on the CSV file that has those.
                String csvWithParsName = applyOnPrevCombo.getSelectedItem().toString() + DAFi.CSVwithParsFileSuffix;
                String pluginFolder = this.fsElement.getString(pluginFolderAttName);
                if (pluginFolder != null && !pluginFolder.isEmpty() && fParameterNameList != null) {
                    File csvWithParsFile = new File(pluginFolder + File.separator + csvWithParsName);
                    if (csvWithParsFile.exists()) {
                        ArrayList<String> parsList = new ArrayList<String>();
                        Scanner scan;
                        try {
                            scan = new Scanner(csvWithParsFile);
                            if (scan.hasNextLine())
                                scan.nextLine(); // Skip header (which is "x")
                            while (scan.hasNextLine()) {
                                String line = scan.nextLine();
                                line = line.replaceAll("^\"|\"$", "");
                                if (line != null && !line.isEmpty())
                                    parsList.add(line);
                            }

                            List<Integer> selections = new ArrayList<Integer>();

                            List<String> allParams = fParameterNames;
                            int numberParams = allParams.size();
                            for (int i = 0; i < numberParams; i++) {
                                String pName = allParams.get(i);
                                if (pName != null && !pName.isEmpty()) {
                                    for (String nameFromCSV : parsList) {
                                        if (pName.startsWith(nameFromCSV)) {
                                            selections.add(i);
                                            break;
                                        }
                                    }
                                }
                            }

                            int indices[] = new int[selections.size()];
                            for (int i = 0; i < selections.size(); i++)
                                indices[i] = selections.get(i);
                            fParameterNameList.setSelectedIndices(indices);
                            fParameterNameList.setEnabled(false);


                        } catch (FileNotFoundException e) {
                        }
                    }
                }
            } else {
                if (fDimXField != null) fDimXField.setEnabled(true);
                if (fDimYField != null) fDimYField.setEnabled(true);
                if (fScaleOptionCheckbox != null) fScaleOptionCheckbox.setEnabled(true);
                if (fApplyOnChildrenCheckbox != null) fApplyOnChildrenCheckbox.setEnabled(true);
                if (fParameterNameList != null) fParameterNameList.setEnabled(true);
            }
        }
    }

    @SuppressWarnings("deprecation")
    @Override
    protected void extractPromptOptions() {
        fOptions = new HashMap<>();
        fParameterNames = new ArrayList<>();

        boolean cellIdParameterIncluded = false;

        for (Object obj : fParameterNameList.getSelectedValues()) {
            String parName = (new StringBuilder()).append("").append(obj).toString();
            // FlowJo's parameter names are often in the form of Name :: Description, we only want the Name part from that
            int parDescIndex = parName.indexOf(" :: ");
            if (parDescIndex > 0) parName = parName.substring(0, parDescIndex);
            fParameterNames.add(parName);
            if (parName.equals(DAFi.cellIdParName))
                cellIdParameterIncluded = true;
        }

        // If plotParameter isn't among the list, we will switch to plotting all that's there
        // TODO
        // We really need the Time parameter, so we select it even if the user doesn't.
        if (isSeqGeq() && !cellIdParameterIncluded)
            fParameterNames.add(DAFi.cellIdParName);

        // Save all the DAFi specific options
        fOptions.put(minPopSizeOptionName, Integer.toString(fMinPopSizeField.getInt()));
        fOptions.put(xDimOptionName, Integer.toString(fDimXField.getInt()));
        fOptions.put(yDimOptionName, Integer.toString(fDimYField.getInt()));
        fOptions.put(scaleOptionName, fScaleOptionCheckbox.isSelected() ? One : Zero);
        fOptions.put(applyOnChildrenOptionName, fApplyOnChildrenCheckbox.isSelected() ? One : Zero);
        if (fApplyOnPrevCombo.getSelectedIndex() <= 0) {
            fOptions.put(applyOnPrevOptionName, fApplyOnPrevCombo.getSelectedItem().toString());
        } else {
            fOptions.put(applyOnPrevOptionName, fApplyOnPrevCombo.getSelectedItem().toString() + DAFi.RDataFileSuffix);
        }

        fShowOutput = fShowOutputCheckBox.isSelected();
    }

    // Is this SeqGeq based on the application name?
    // This is used to figure out whether we should be including CellIds in the CSV files
    public static boolean isSeqGeq() {
        if (FJApplication.getInstance() != null &&
                FJApplication.getInstance().getAppName() != null &&
                FJApplication.getInstance().getAppName().toLowerCase().contains("seqgeq"))
            return true;
        return false;
    }

    private static final double epsilon = 0.1;


    private void addGatingML(ExternalAlgorithmResults result, List<Float> values) {
        System.out.println("Adding gates to " + pluginName + " using: " + values);
        SElement gate = new SElement("gating:Gating-ML");
        int curPop = 0;

        Collections.sort(values);
        for (Float x : values) {

            SElement rectGateElem = new SElement("gating:RectangleGate");
            rectGateElem.setString("gating:id", pluginName + "_" + curPop);
            curPop++;
            gate.addContent(rectGateElem);
            SElement dimElem = new SElement("gating:dimension");
            dimElem.setDouble("gating:min", x - epsilon / 2);
            dimElem.setDouble("gating:max", x + epsilon / 2);
            rectGateElem.addContent(dimElem);
            SElement fcsDimElem = new SElement("data-type:fcs-dimension");
            fcsDimElem.setString("data-type:name", pluginName);
            dimElem.addContent(fcsDimElem);
        }
        result.setGatingML(gate.toString());
    }

    // Use FlowJo's CSV reader instead of manually and get the column where the categorical is found
    private List<Float> extractUniqueValuesForParameter(File sampleFile) {
        HashSet<Float> uniqueValues = new HashSet<>();
        try {
            CSVReader reader = new CSVReader(new FileReader(sampleFile));
            List<String[]> entries = reader.readAll();
            int categoricalColIndex = -1;
            for (String[] entry : entries) {
                for (int i = 0; i < entry.length; i++) {
                    if (categoricalColIndex == -1) {
                        if (entry[i].equalsIgnoreCase(pluginName)) {
                            categoricalColIndex = i;
                        }
                    } else if (i == categoricalColIndex) {
                        try {
                            float val = Float.parseFloat(entry[i]);
                            val = (float) (epsilon * Math.round(val / epsilon));
                            uniqueValues.add(val);
                        } catch (NumberFormatException e) {
                            System.out.println("Error in parsing " + entry[i]);
                            //We should not get any weird formats but we could see commas or related that break stuff
                        }
                    }
                }
            }
        } catch (FileNotFoundException e) {
//            e.printStackTrace();
            System.out.println();
        } catch (IOException e) {
//            e.printStackTrace();
        }


        return new ArrayList<>(uniqueValues);
    }


}
